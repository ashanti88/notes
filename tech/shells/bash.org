#+TAGS: shell sh bash scripting shell_script


* Bash
* Files
/etc/profile - 
~/.bash_logout - this is run when loging out of shell window
~/.bash_profile - user specific preferences read by login
~/.bashrc - this is read only by shells that are both interactive and non-login

- order of the files
  - /etc/profile
  - ~/.bash_profile
  - ~/.bashrc
    
* Description
* Usage
** Precedence of config files
- non-interactive
  /etc/profile
  ~/.bash_profile
  ~/.bash_login

- interactive
  /etc/bash.bashrc
  ~/.bashrc
  
- Non-interactive shell
When you open a terminal emulator (gnome-terminal for example), you are executing what is known as an interactive, non-login shell. 

- Interactive shell
When you log into your machine from the command line, or run a command such as su - username, you are running an interactive login shell.

** Globbing
- Also known as wildcards  
ls host* - list anything that starts with host
ls ?ost - ? is one char, list all files one char + "ost"
ls [hm]ost - ls any file that match host or most
ls [!hm] - list any file one char + "ost", but not host or most
ls [0-9][0-9]script - list any file names script that is prefixed with two numbers

* Lecture
* Tutorial
** Linux Academy - Linux Essentials Scripting Lesson

- Variables - $ANYNAME
  
- Arguments
  - $1 first argument
  - $2 second argument
  - $? exit code/status
    
- Building Blocks of the script
  
#! - shebang

/bin/bash - the Bourne Again Shell

Variable - arguments to pass to to the script

Arguments - options we pass to our scripts

echo - prints what we tell echo to print to the screen

for - loops through and iterates through data for us

if - used for conditional coding based on exit status code for example

Exit - exit or stop a script function

&& - AND

|| - OR

- if/then
  
#+BEGIN_EXAMPLE
if condition then
	command
else
	command
fi
#+END_EXAMPLE

  - options for if/then/else
    d - checks to see if the specified directory exist
    e - checks to see if the specified file exist
    f - checks to see if the specified file exist and it's a regular file
    G - checks to see if the specified file exist and it'ss owned by a specific group
    h or L - checks to see if the specified file exist and if it is a symbolic link
    O - checks to see if the specified file exist and if it is owned by a specific UID
    r - checks to see if the specified file exist and if the read permission is granted
    w - checks to see if the specified file exist and if the write permission is granted
    x - checks to see if the specified file exist and of the execute permissions is granted
    
- Looping Structures
  - while - loops, execute over and over until a specified condition is no longer true
    #+BEGIN_EXAMPLE
    while condition
    do
    	script command
    done
    #+END_EXAMPLE

  - until - run over and over as long as the condition is false and as soon as it the condition is ture it will stop
    #+BEGIN_EXAMPLE
    until condition
    do
    	script command
    done	
    #+END_EXAMPLE

  - for - will loop a specified number of times
    - three options for creating a number sequence with seq:
      - if specify a single value, the sequence starts at one, increments by one, and ends at the specified value.
      - If specify two values, the sequence starts at the first value, increments by one, and ends at the second value.
      - If specify three values, the sequence starts at the first value, increments by the second value and ends at the third value.
    #+BEGIN_EXAMPLE
    for i in `seq 15`
    	do
	    echo "The current number in the sequence is $i"
        done	
    exit 0
    #+END_EXAMPLE

- simple script example
#+BEGIN_EXAMPLE
#!/bin/bash
# list the contents the directory and output to a file

location=$1
filename=$2

if [ -z "$location" ]
then
	echo "please provide location argument"
	exit 0
fi

if [ -z "$filename" ]
then
	echo "please provide a filename"
	exit 0
fi

ls $location >> $filename
echo "The cript is complete and has indexed the $location directory"
echo "###############"
echo "Displaying contents of our $filename
echo "###############"
echo $filename
#+END_EXAMPLE

* Books
** [[file://home/crito/Documents/Linux/Shell/Bash/bash-Cookbook.pdf][bash Cookbook - O'Reilly]]
** [[file://home/crito/Documents/Linux/Shell/Bash/bash-Pocket_Reference.pdf][bash - Pocket Reference]]
** [[file://home/crito/Documents/Linux/Shell/Bash/Learning_the_bash_Shell.pdf][Learning the Bash Shell]]
** [[file://home/crito/Documents/Linux/Shell/Bash/Pro_Bash_Programming_2e.pdf][Pro Bash Programming 2e]]
** [[file://home/crito/Documents/Linux/Shell/Bash/Pro_Bash_Programming-Scripting_the_GNU-Linux_Shell.pdf][Pro Bash Programming - Scripting the GNU/Linux Shell]]
*** hello-world
#+BEGIN_SRC sh

#!/bin/bash
#: Title	: hello_world.sh
#: Date		: 2007-10-01
#: Author	: "Alick Mitchell" <mitchell@gmail.com>
#: Version	: 1.0
#: Desription	: print Hello, World!
#: Options	: None

printf "Hello, World!"
#+END_SRC

*** Parameters
#+BEGIN_SRC sh
#!/bin/bash
#: Title	: Hello You
#: Date		: 2010-01-04
#: Author	: "Alick Mitchell" <mitchell@gmail.com>
#: Version	: 1.0
#: Desription	: "Say hello to you"
#: Options	: one positional input

printf "Hello, %s!\n" "$1"
#+END_SRC
- The limit is 9, 10 is interpreted as the first arg
- To access positionals greater than 9 you must use ${10}, braces
  
- Special Parameters
  - $$ - the current pid
  - $? - the exit code of the last-executed command
  - $_ - the last arg of the command
  - $! - the pid of the last command run in the bkground
  - $- - 

- setting spaces around formated string
#+BEGIN_SRC sh
#!/bin/bash
#: Title	: Hello You
#: Date		: 2010-01-04
#: Author	: "Alick Mitchell" <mitchell@gmail.com>
#: Version	: 1.0
#: Desription	: "Say hello to you"
#: Options	: one positional input

printf "%12.4s %04.2f\n" Jack 1200.333 Jackson 44444.232323 Walter 54.675
#+END_SRC

#+RESULTS:
| Jack |  1200.33 |
| Jack | 44444.23 |
| Walt |    54.67 |

*** Report
#+BEGIN_SRC sh
#+BEGIN_SRC sh
#!/bin/bash
#: Title	: Sales Report
#: Date		: 2010-01-04
#: Author	: "Alick Mitchell" <mitchell@gmail.com>
#: Version	: 1.0
#: Desription	: Print formatted sales report
#: Options	: None

divider=====================================================
divider=$divider$divider

#Format strings for printf
header="\n%-10s %11s %8s %10s\n"
format=" %-10s %11.2f %8d %10.2f\n"

#Width of divider
totalwidth=44

#Print categories
printf "$header" ITEM "PER UNIT" NUM TOTAL

#Print divider to match width of report
printf "%$totalwidth.${totalwidths}s\n" "$divider"

#Print lines of report
printf "$format" \
	Chair 79.95 4 319.8\
	Table 209.99 1 209.99\
	Armchair 315.46 2 630.92
#+END_SRC

*** Redirection

redirect std_error to a file
#+BEGIN_SRC sh
printf '%s\n%v\n' OK? Oops! > FILE 2> ERRORFILE
#+END_SRC
- As v is an invalid parameter 2> will redirect the error to a file, instead of to the screen
  
redirect std_error to /dev/null
#+BEGIN_SRC sh
#+END_SRC
 - Same as above, but now the errors are sent to /dev/null
   
send std_outpu and std_error to the same place
#+BEGIN_SRC sh
printf '%s\n%v\n' OK? Oops! 2>&1 > FILE
#+END_SRC

*** Piping to a file
this will print to std_output and to a file
#+BEGIN_SRC sh
printf "%s\n" "$RANDOM" "$RANDOM" "$RANDOM" "$RANDOM" "$RANDOM" | tee FILENAME
#+END_SRC

*** Command Substitution
This add the output of date to the variable $today
#+BEGIN_SRC sh
today=`date` 
today=$( date )
#+END_SRC
the brackets is the newer and perfered method

*** Tests- Test if this file is present or a file
#+BEGIN_SRC sh
test -e /tmp/test_file
echo $?
test -f /tmp/test_file
echo $?
#+END_SRC
e - existence of a file
f - file
h - symbolic link
L - symbolic link
d - directory
x - is the file executable

- Test cmd can be substituted for []
#+BEGIN_SRC sh
[ -e /tmp/test_file ]
echo $?
[ -f /tmp/test_file ]
echo $?
#+END_SRC

- Arithmetic testing
#+BEGIN_SRC sh
test 1 -eq 1
echo $?
[ 1 -eq 1 ]
echo $?
#+END_SRC
eq - equal to
ne - not equal to
gt - greater than
lt - less than
ge - greater than or equal to
le - less than or equal to


*** Conditionals
- testing if entered number is greater than 10
#+BEGIN_SRC sh
printf "Please enter a number no greater than 10: "
read number
if [ "$number" -le 10 ]
then
	printf "%d is lower than 10\n" "$number"
	exit 0
else	
	printf "You entered a number larger than 10\n" >&2 
	exit 1
fi
#+END_SRC

- testing if a number is between a range
#+BEGIN_SRC sh
printf "Please enter a number between 10 and 20: "
read number
if [ "$number" -lt 10 ]
then
	printf "%d is lower than 10\n" "$number"
	exit 1
elif [ "$number" -gt 20 ]
then
	printf "%d is greate than 20\n" "$number"
	exit 1
else
	printf "%d is in the correct range\n" "$number"
fi
#+END_SRC

- Case
#+BEGIN_SRC sh
case $1 in
	*"$2"*) true ;;
	*) false ;;
esac
#+END_SRC
does one string contain another

*** Loops(while,until,for)

- While
#+BEGIN_SRC sh
n=1
while [ $n -le 10 ]
do
	printf "%d" $n
	n =$(( $n + 1 ))
done
#+END_SRC
print the numbers 1 to 10

- Until
#+BEGIN_SRC sh
n=1
until [ $n -gt 10 ]
do
	echo "$n"
	n=$(( $n + 1 ))
done
#+END_SRC

- For
#+BEGIN_SRC sh
for var in UK US GR
do
	printf "%s\n" "$var"
done
#+END_SRC

#+BEGIN_SRC sh
for (( n=1; n<=10; ++n ))
do
	echo "$n"
done
#+END_SRC
print 1 through 10

*** Command-Line Parsing and Expansion
sa.sh
#+BEGIN_SRC sh
pre=:
post=:
printf "$pre%s$post\n" "$@"
#+END_SRC
this print all the provided arguments one per-line

- $@ - this special variable signifies all supplied arguments
  - if it is used wiht "$@" quotes white space will retain it's meaning when parsing
  - if no quotes are used "$@" an argument such as "boiled egg" would become two arguments
	
#+BEGIN_EXAMPLE
sa \ this "is a" 'demonstration of' \  quotes\ and\ escapes
#+END_EXAMPLE
this line is passing five arguments
: this:
:is a:
:demonstration of:
: :
:quotes and escapes:

- Brace Expansion
#+BEGIN_EXAMPLE
sa {one,two,three}
#+END_EXAMPLE
:one:
:two:
:three:

#+BEGIN_EXAMPLE
sa {1..3}
#+END_EXAMPLE
:1:
:2:
:3:

#+BEGIN_EXAMPLE
sa {a..c}
#+END_EXAMPLE
:a:
:b:
:c:

#+BEGIN_EXAMPLE
sa pre{d,l}ate
#+END_EXAMPLE
:predate:
:prelate:

- Command Substitution
#+BEGIN_SRC sh
wc -l $( date +%Y-%m-%d ).log
#+END_SRC
this will count the lines in a file whose name includes today's date

- Parsing Options
parseopts.sh
#+BEGIN_EXAMPLE
progname=${0##*/} ## Get the name of the script without its path

## Default values
verbose=0
filename=

## List of options the program will accept;
## those options that take arguments are followed by a colon
optstring=f:v

## The loop calls getopts until there are no more options on the command line
## Each option is stored in $opt, any option arguments are stored in OPTARG
while getopts $optstring opt
do
	case $opt in
		f) filename=$OPTARG ;; ## $OPTARG contains the argument to the option
		v) verbose=$(( $verbose + 1 )) ;;
		*) exit 1 ;;
	esac	
done

## Remove options from the command line
## $OTIND points to the next, unparsed argument
shift "$(( $OPTIND - 1 ))"

## Check whether a filename was entered
if [ -n "$filename" ]
then
	if [ $verbose -gt 0 ]
	then
		printf "Filename is %s\n" "$filename"
	if
else 	
	if [ $verbose -gt 0 ]
	then
		printf "No filename entered\n" >&2
	fi
	exit 1
fi

## Check whether file exists
if [ -f "$filename" ]
then
	if [ $verbose -gt 0 ]
	then
		printf "Filename %s found\n" "$filename"
	fi
else
	if [ $verbose -gt 0 ]
	then
		printf "File, %s, does not exist\n" "$filename" >&2
	fi
	exit 2
fi

## If the verbose option is selected,
## print the number of arguments remaining on the command line
if [ $verbose -gt 0 ]
then
	printf "Number of arguments is %d\n" "$#"
fi
#+END_EXAMPLE

* Links
