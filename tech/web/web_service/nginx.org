#+TAGS: web_server nginx load_balancer caching_server


* Nginx
HomePage: [[https://www.lighttpd.net/][lighttpd.net]]
HomePage: [[https://www.nginx.com/resources/wiki/][nginx.com]]
* Files
/etc/nginx/conf.d/    - this contains the config files for virtual servers, ssl etc
/etc/nginx/nginx.conf - this is the main configuration file
/usr/share/nginx/html - this is the location of the default page
/usr/lib64/nginx/modules - this is where nginx keeps it's modules (there is a symbolic link in /etc/nginx)

** /etc/nginx/conf.d/ssl.conf
#+BEGIN_EXAMPLE
server {
        listen  443;
        server_name _;

        ssl                     on;
        ssl_certificate         /etc/nginx/ssl/nginx.crt;
        ssl_certificate_key     /etc/nginx/ssl/nginx.key;

        ssl_session_timeout     5m;

        ssl_protocols           SSLv2 SSLv3 TLSv1;
        ssl_ciphers "EECDH+AESGCM:EDH+AESGCM:ECDHE-RSA-AES128-GCM-SHA256:AES256+EECDH:DHE-RSA-AES128-GCM-SHA256:AES256+EDH:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA:ECDHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES256-GCM-SHA384:AES128-GCM-SHA256:AES256-SHA256:AES128-SHA256:AES256-SHA:AES128-SHA:DES-CBC3-SHA:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!MD5:!PSK:!RC4";
        ssl_prefer_server_ciphers       on;
}
#+END_EXAMPLE

* Description
Nginx is a web server that is extremely good at serving large amounts of static content.
It is considered less efficient at delivering dynamic content.
* Configuration
** Administration
*** Syntax
+ Comments
In nginx config files the #-hash is used to comment a line
+ terminating lines
nginx terminates lines/statements with the ;-semicolon

*** nginx.conf
**** First Section
user www-data;  - defines the system user that runs the nginx server
worker_processes 4; - this specifies how many threads, instances of nginx to run
pid /run/nginx.pid; - this specifies where the master pid is to be stored

events {
        worker_connections 768;
        # multi_accept on;
        # accept_multex off;
}

**** Second Section
http {


        include /etc/nginx/mime.types; - this includes what is inside mime.type into the http block
        default_type application/octet-stream;
	
	##
        ## Logging Settings - this sets the location for log files
        ##

        access_log /var/log/nginx/access.log;
        error_log /var/log/nginx/error.log;

        ##
        ## Gzip Settings
        ##

        gzip on; - this tells nginx to use on the fly gzip compression to reduce bandwidth usage
        gzip_disable "msie6";
	
**** Virtual Host Configs
        ##
        # Virtual Host Configs - this sets the location of the virtual host config files
        ##

        include /etc/nginx/conf.d/*.conf;
        include /etc/nginx/sites-enabled/*;
}

*** sites-enabled/*
The above /etc/nginx/sites-enabled/ directory usually contain symbolic links to files in /etc/nginx/available-sites/*

**** /etc/nginx/sites-available/default
server {
        listen 80 default_server; - default indicates to direct traffic to this instance if no other virtual host matches
        listen [::]:80 default_server ipv6only=on; - same as above but IPv6

        root /usr/share/nginx/html;
        index index.html index.htm;

        # Make site accessible from http://localhost/
        server_name example.com .example.com; - this should be set to the domain and enables multiple domains to use the same ip. 

        location / {
                # First attempt to serve request as file, then
                # as directory, then fall back to displaying a 404.
                try_files $uri $uri/ /index.html;
                # Uncomment to enable naxsi on this location
                # include /etc/nginx/naxsi.rules
        }
}
- server_name example.com .example.com example.*;
  - .example.com  - match all sub-domains
  - *.example.com - match all sub-domains
  - example.*     - match all top level domains
  - ""            - no hostname, will process all requests without hostname or with ip addr

**** Log Files 
+ Disable logs files
access_log off;

**** Location 
This section of the server block tells nginx how to deal with requests to resources within the server.
location ~ IndexPage\.php${}
The ~ indicates that nginx will perform a regular expression match. These matches are case sensitive.
location ~* IndexPage\.php${}
This will now match without case sensitivity.
location ~* \.(pl|cgi|perl|prl){}
This will now match to any perl file .pl .cgi .perl .prl){}
** HowTos
*** Cento/Fedora

+ Initial Set-Up
CHECK WHAT STATE SELINUX IS IN
1. Stop apache if installed
#+BEGIN_SRC sh
sudo systemctl stop httpd.service
#+END_SRC
2. Disable apache from starting at boot
#+BEGIN_SRC sh
sudo systemctl disable httpd.service
#+END_SRC
3. Install epel repository
#+BEGIN_SRC sh
sudo yum install epel-release
#+END_SRC
4. Install nginx
#+BEGIN_SRC sh
sudo yum -y install nginx
#+END_SRC
5. Start Nginx and enable at boot
#+BEGIN_SRC sh
sudo systemctl start nginx.service
sudo systemctl enable nginx.service
#+END_SRC

+ Create User for Webspace
#+BEGIN_SRC sh
sudo adduser nginxsite
sudo passwd nginxsite
#+END_SRC

+ Set DocumentRoot
1. Create directory to hold site
#+BEGIN_SRC sh
sudo mkdir -p /var/www/nginxsite.com/public_html
#+END_SRC
2. Create test index.html use standard html template hello world
#+BEGIN_SRC sh
sudo touch /var/www/nginxsite.com/public_html/index.html
#+END_SRC
3. Change ownership of this directory to the created user
#+BEGIN_SRC sh
sudo chown -R nginxsite:nginxsite /var/www/nginxsite.com/public_html
#+END_SRC
4. Set file permissions
#+BEGIN_SRC sh
sudo chmod 755 /var/www/nginxsite.com/public_html
#+END_SRC

+ Configure Nginx to recognise new VirtualHosts(Server Blocks)
1. Make directories to hold site configs
#+BEGIN_SRC 
mkdir /etc/nginx/sites-available
mkdir /etc/nginx/sites-enabled
#+END_SRC
2. Add the following to to /etc/nginx/nginx.conf
#+BEGIN_SRC 
include /etc/nginx/sites-enabled/*.conf;
server_names_hash_bucket_size 64;
#+END_SRC

+ Create the Server Block
1. create the file /etc/nginx/sites-available/nginxsite.com.conf
#+BEGIN_SRC 
server {
listen       80;
server_name  nginxsite.com www.nginxsite.com;
location / {
root   /var/www/nginxsite.com/public_html;
index  index.html index.htm;
try_files $uri $uri/ =404;
}    error_page   500 502 503 504  /50x.html;
location = /50x.html {
root   html;
}
}
#+END_SRC
2. create the symbolic link from sites-available to sites-enabled. Makesure that absoulte path is used for the link
#+BEGIN_SRC sh 
sudo ln -s /etc/nginx/sites-available/nginxsite.com.conf /etc/nginx/sites-enabled/nginxsite.com.conf
#+END_SRC
3. test the config and restart the service it syntax is correct
#+BEGIN_SRC sh
sudo nginx -t
sudo systemctl restart nginx.service
#+END_SRC

*** Link
[[https://www.godaddy.com/garage/tech/config/how-to-install-and-configure-nginx-on-centos-6/][Install and Configure NGINX on CentOS 6]]
* Usage
- view nginx version
#+BEGIN_SRC sh
nginx -v
#+END_SRC

- view all version and module details
#+BEGIN_SRC sh
nginx -V
nginx -V 2>&1 | tr -- - '\n' | grep _module
#+END_SRC
the second line provides the output in a more sane manner

- testing the nginx configuration syntax
#+BEGIN_SRC sh
nginx -t
#+END_SRC

** Installation (RHEL)
- Install epel repository 
#+BEGIN_SRC sh
yum update
wget http://dl.fedoraproject.org/pub/epel/6/x86_64/epel-release-6-8.noarch.rpm
rpm -uvh epel-release-6-8.noarch.rpm
yum repolist
yum update
#+END_SRC

- Install nginx
#+BEGIN_SRC sh
yum install nginx
#+END_SRC

- Start and Enable the service (Sysvinit)
#+BEGIN_SRC sh
chkconfig nginx on
service nginx start
#+END_SRC

- Test nginx
#+BEGIN_SRC sh
yum install lynx
lynx http://localhost
#+END_SRC
This should show the default nginx page if installed correctly

** Installation on CentOS7

- add the Nginx repo
/etc/yum.repos.d/nginx.repo
#+BEGIN_EXAMPLE
[nginx]
name=nginx repo
baseurl=http://nginx.org/packages/centos/7/$basearch/
gpgcheck=0
enabled=1
#+END_EXAMPLE

- update the system to allow the new repo to be acknowledged
#+BEGIN_SRC sh
yum install -y nginx
#+END_SRC

- start and enable the service
#+BEGIN_SRC sh
systemctl start nginx
systemctl enable nginx
#+END_SRC

- curl the localhost and we will see the nginx test page
#+BEGIN_SRC sh
curl http://localhost
#+END_SRC

** Installation on Ubuntu 16.04
   
- update the machine
#+BEGIN_SRC sh
apt-get update
#+END_SRC

- though we could use the available version of Nginx it came sometimes be date, so it's better to use Nginx's own repo
#+BEGIN_SRC sh
curl -o nginx_signing.key http://nginx.org/keys/nginx_signing.key
apt-key add nginx_signing.key
#+END_SRC

/etc/apt/sources.list
#+BEGIN_EXAMPLE
# Official Nginx repo
deb http://nginx.org/packages/ubuntu/ xenial nginx
deb-src http://nginx.org/packages/ubuntu/ xenial nginx
#+END_EXAMPLE

- update date the system to acknowledged the new repo
#+BEGIN_SRC sh
apt-get update
#+END_SRC

- install the Nginx package
#+BEGIN_SRC sh
apt-get install -y nginx
#+END_SRC

- start and enable the service
#+BEGIN_SRC sh
systemctl start nginx
systemctl enable nginx
#+END_SRC

- confirm the installation
#+BEGIN_SRC sh
curl http://localhost
#+END_SRC

** Basic Configuration vhost.d and /var/www/html
/etc/nginx/nginx.conf

- adding a vhost.d directory to the configuration
#+BEGIN_EXAMPLE
include /etc/nginx/vhost.d/*.conf
#+END_EXAMPLE
this would be placed under the other include files

- create the vhost.d directory
#+BEGIN_SRC sh
cd /etc/nginx
mkdir vhost.d
cd vhost.d
mv /etc/nginx/conf.d/default.conf .
#+END_SRC

- edit the default.conf root filesystem
#+BEGIN_EXAMPLE
location / {
	root  /var/www/html;
	index index.html index.htm;
}
#+END_EXAMPLE

- create /var/www/html
#+BEGIN_SRC sh
mkdir /var/www/html
echo "This is our new Config and Index" > /var/www/html/index.html
#+END_SRC

- test the new configuration
#+BEGIN_SRC sh
nginx -t
#+END_SRC

- restart the service if test is successful
#+BEGIN_SRC sh
service nginx restart
lynx http://localhost
#+END_SRC
this should now print the new index.html

** Setting up our own default.conf and a virtual host
- create a new default /etc/nginx/conf.d/default.conf
#+BEGIN_EXAMPLE
server {
    listen 80 default_server;
    server_name _;
    root /usr/share/nginx/html;
}
#+END_EXAMPLE

- crate a virtual host /etc/nginx/conf.d/example.conf
#+BEGIN_EXAMPLE
server {
    listen 80;
    server_name example.com www.example.com;
    root /var/www/example.com/html;
}
#+END_EXAMPLE

- create example.com/html directory
#+BEGIN_SRC sh
mkdir -p /var/www/example.com/html
echo "<h1>Hello, Example.com</h1>" > /var/www/example.com/html/index.html
#+END_SRC

- test and reload nginx
#+BEGIN_SRC sh
nginx -t
systemctl reload nginx
#+END_SRC

- use curl to test example.com
#+BEGIN_SRC sh
curl --header "Host: example.com" localhost
#+END_SRC
this would cause an SELinux error if enabled

- set the correct SELinux context on the example.com directory
#+BEGIN_SRC sh
semanage fcontext -a -t httpd_sys_content_t '/var/www/(/.*)?'
restorecon -R -v /var/www
#+END_SRC

- our page should now be available
#+BEGIN_SRC sh
curl --header "Host: example.com" localhost
#+END_SRC

** Setting up Customized Error Pages
- setting a default error page
/etx/nginx/conf.d/default.conf
#+BEGIN_EXAMPLE
server {
    listen 80 default_server;
    server_name _;
    root /var/www/html;
    
    error_page 404 /404.html;
    error_page 500 501 502 503 504 /50x.html;
}
#+END_EXAMPLE

- create the error_page
#+BEGIN_SRC sh
echo "<h1>404 Page Not Found</h1>" > /var/www/html/404.html
#+END_SRC

- reload the nginx service
#+BEGIN_SRC sh
nginx -t
systemctl reload nginx
#+END_SRC

** Setting up Admin section with password (auth_basic)
- add the location directive
#+BEGIN_EXAMPLE
server {
    listen 80 default_server;
    server_name _;
    root /var/www/html;
    
    location = /admin.html {
        auth_basic "Login Required";
        auth_basic_user_file /etc/nginx/.htpasswd;
    }
    
    error_page 404 /404.html;
    error_page 500 501 502 503 504 /50x.html;
}
#+END_EXAMPLE

- create a temp admin page
#+BEGIN_SRC sh
echo "<h1>Admin Page </h1>" > /var/www/html/admin.html
#+END_SRC

- install the htpasswd package
#+BEGIN_SRC sh
yum install -y httpd-tools
apt-get install apache2-utils
#+END_SRC

- generate the .htpasswd
#+BEGIN_SRC sh
htpasswd -c /etc/nginx/.htpasswd admin
#+END_SRC
this will prompt you for a password and add it to the file

- confirm the config and reload
#+BEGIN_SRC sh
nginx -t
systemctl reload nginx
#+END_SRC

- confirm that authentication is required
#+BEGIN_SRC sh
curl -u admin:password localhost/admin.html
#+END_SRC
with a gui browser a popup will challenge for the username and password 

** Generating Self-Signed Certificates

- create a directory to hold the certs
#+BEGIN_SRC sh
mkdir /etc/nginx/ssl
#+END_SRC

- create a certifiacte
#+BEGIN_SRC sh
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/nginx/ssl/private.key -out /etc/nginx/ssl/public.pem
#+END_SRC
we will be prompted for company infromation but this isn't compulsory

** Configuring the Host for SSL/TLS/HTTPS

- edit the default.conf to accept ssl traffic
#+BEGIN_EXAMPLE
server {
    listen 80 default_server;
    listen 443 ssl;
    server_name _;
    root /var/www/html;
    
    ssl_certificate /etc/nginx/ssl/public.pem;
    ssl_certificate_key /etc/nginx/ssl/private.key;
    
    location = /admin.html{
        auth_basic "Login Required";
        auth_basic_user_file /etc/nginx/.htpasswd;
    }
    
    error_page 404 /404.html;
    error_page 500 501 502 503 504 /50x.html;
}
#+END_EXAMPLE
- the following lines need to be added to enable https
listen 443 ssl
ssl_certificate /etc/nginx/ssl/public.pem
ssl_certificate_key /etc/nginx/ssl/private.key

- test and reload nginx
#+BEGIN_SRC sh
nginx -t
systemctl reload nginx
#+END_SRC

- confirm with curl
#+BEGIN_SRC sh
curl -k https://localhost
#+END_SRC
k - insecure (will allow self signed certs without warning)

** Force HTTP to HTTPS
   
- create an individual server block for both http and https
#+BEGIN_EXAMPLE
server {
    listen 80 default_server;
    server_name _;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl default_server;
    server_name _;
    root /var/www/html;
    
    ssl_certificate /etc/nginx/ssl/public.pem;
    ssl_certificate_key /etc/nginx/ssl/private.key;
    
    # Remove the .html from files
    rewrite ^(/.*)\.html(\?.*)?$ $1$2 redirect;
    # this removes any trailing / on requests
    rewrite ^/(.*)/$ /$1 redirect;
    
    location / {
        try_files $uri/idex.html $uri.html $uri/ $uri =404;
    }

    location = /admin.html{
        auth_basic "Login Required";
        auth_basic_user_file /etc/nginx/.htpasswd;
        try_files $uri/idex.html $uri.html $uri/ $uri =404;
    }
    
    error_page 404 /404.html;
    error_page 500 501 502 503 504 /50x.html;
}
#+END_EXAMPLE

- test and reload
#+BEGIN_SRC sh
nginx -t
systemctl reload nginx
#+END_SRC

** SSL Certification Management
   
- create an ssl directory
#+BEGIN_SRC sh
mkdir -p /etc/nginx/ssl
cd ssl
#+END_SRC

- create the server csr and key files
#+BEGIN_SRC sh
openssl genrsa -des3 -out server.key 1024
openssl req -new -key server.key -out server.csr
#+END_SRC

- remove passphrase from server.key as a restart of nginx will always prompt for the key
#+BEGIN_SRC sh
cp server.key server.key.org
openssl rsa -in server.key.org -out server.key
#+END_SRC

- create the self signed certificate
#+BEGIN_SRC sh
openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
#+END_SRC

- add the certificate to the vhost file
#+BEGIN_EXAMPLE
server {
	listen 80;

	root /var/www/html/myexample;
	index index.html index.htm index.php;
	
	server_name myexample.local www.myexample.local;
}

server {
	listen 443;

	root /var/www/html/myexample;
	index index.html index.htm index.php
	
	server_name www.myexample.local myexample.local
	
	ssl on;
	ssl_certificate /etc/nginx/ssl/server.crt;
	ssl_certificate_key /etc/nginx/ssl/server.key;
}
#+END_EXAMPLE

- test configuration and restart service
#+BEGIN_SRC sh
nginx -t
service nginx restart
lynx https://www.myexample.local
#+END_SRC

** Improving SSL Configuration
https://wiki.mozilla.org/Security/Server_Side_TLS
   
#+BEGIN_EXAMPLE
server {
    listen 80 default_server;
    server_name _;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl default_server;
    server_name _;
    root /var/www/html;
    
    ssl_certificate /etc/nginx/ssl/public.pem;
    ssl_certificate_key /etc/nginx/ssl/private.key;

    ssl_session_timeout 1d; # this variables stop the ssl handshake having to take place everytime they visit (5 minutes default)
    ssl_session_cache  shared:SSL:50m; # 1m can store about 4000 sessions
    ssl_seesion_tickets off;
    
    ssl_protocols TLSv1.2;
    ssl_ciphers 'ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256';
    ssl_prefer_server_ciphers on;
    
    # do not allow port 80 for 6mths
    add header Strict-Transport-Security max-age=15768000;
    
    # OSCP - Online Cerificate Status Protocol - The server can make the request to the Cert auth and cache it saving the client having to perform this request
 
    ssl_stapling on;
    
    # Remove the .html from files
    rewrite ^(/.*)\.html(\?.*)?$ $1$2 redirect;
    # this removes any trailing / on requests
    rewrite ^/(.*)/$ /$1 redirect;
    
    location / {
        try_files $uri/idex.html $uri.html $uri/ $uri =404;
    }

    location = /admin.html{
        auth_basic "Login Required";
        auth_basic_user_file /etc/nginx/.htpasswd;
        try_files $uri/idex.html $uri.html $uri/ $uri =404;
    }
    
    error_page 404 /404.html;
    error_page 500 501 502 503 504 /50x.html;
}
#+END_EXAMPLE

** Adding ModSecurity to Nginx

- install required tools and dependencies
#+BEGIN_SRC sh
yum groupinstall 'Development tools'
yum install -y \
geoip-devel \
gperftools-devel \
libcurl-devel \
libxml2-devel \
libxslt-devel \
libgd-devel \
lmdb-devel \
openssl-devel \
pcre-devel \
perl-ExtUtils-Embed \
yajl-devel \
zlib-devel
#+END_SRC

- clone ModSecurity, compile and install
#+BEGIN_SRC sh
cd /opt
git clone --depth 1 -b v3/master https://github.com/SpiderLabs/ModSecurity
cd ModSecurity
git submodule init 
git submodule update
./build.sh
./configure
make
make install
#+END_SRC

- now we can build the a dynamic module using the ModSecurity-nginx project
#+BEGIN_SRC sh
cd /opt
git clone --depth 1 https://github.com/SpiderLabs/ModSecurity-nginx.git
#+END_SRC

- download and unpack Nginx Source
#+BEGIN_SRC sh
nginx -v
wget http://nginx.org/download/nginx-1.12.2.tar.gz
tar xvzf nginx-1.12.2.tar.gz
#+END_SRC

- Configure and build the dynamic module
#+BEGIN_SRC sh
cd nginx-1.12.2
./configure --with-compat --add-dynamic-module=../ModSecurity-nginx
make modules
cp objs/ngx_http_modsecurity_module.so /etc/nginx/modules/
#+END_SRC

- Load the Modsecurity Module
/etc/nginx/nginx.conf
#+BEGIN_EXAMPLE
user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;


# Load ModSecurity dynamic module
load_module /etc/nginx/modules/ngx_http_modsecurity_module.so;


events {
    worker_connections  1024;
}

#+END_EXAMPLE
the module has to be loaded before the events section

- now copy the default configuration and amend for SELinux
#+BEGIN_SRC sh
mkdir /etc/nginx/modsecurity
cp /opt/ModSecurity/modsecurity.conf-recommended /etc/nginx/modsecurity/modsecurity.conf
#+END_SRC

/etc/nginx/modsecurity/modsecurity.conf
#+BEGIN_EXAMPLE
SecAuditLog /var/log/nginx/modsec_audit.log
#+END_EXAMPLE
this needs to be altered as SELinux will not allow Nginx to write to /var/log/modsec_audit.log

- enable ModSecurity in the primary server block
#+BEGIN_EXAMPLE
server {
    listen 80 default_server;
    server_name _;
    return 301 https://$host$request_uri;
}

server {
    listen 443 ssl default_server;
    server_name _;
    root /usr/share/nginx/html;

    modsecurity on;
    modsecurity_rules_file /etc/nginx/modsecurity/modsecurity.conf;

    ssl_certificate /etc/nginx/ssl/public.pem;
    ssl_certificate_key /etc/nginx/ssl/private.key;

    rewrite ^(/.*)\.html(\?.*)?$ $1$2 redirect;
    rewrite ^/(.*)/$ /$1 redirect;

    location / {
        try_files $uri/index.html $uri.html $uri/ $uri =404;
    }

    location = /admin {
        auth_basic "Login Required";
        auth_basic_user_file /etc/nginx/.htpasswd;
        try_files $uri/index.html $uri.html $uri/ $uri =404;
    }

    error_page 404 /404.html;
    error_page 500 501 502 503 504 /50x.html;
}
#+END_EXAMPLE

- test and reload to enable the module
#+BEGIN_SRC sh
nginx -t
systemctl reload nginx
#+END_SRC

- OWASP does provide a rule set that can be pulled to add to Modsecurity
#+BEGIN_SRC sh
cd /etc/nginx/modsecurity
git clone https:/github.com/SpiderLabs/owasp-modsecurity-crs.git
cd owasp-modsecurity-crs
#+END_SRC

- copy all the rules and remove the .example from the name
#+BEGIN_SRC sh
cp crs-setup.conf{.example,}
cp rules/REQUEST-900-EXCLUSION-RULES-BEFORE-CRS.conf{.example,}
cp rules/RESPONSE-999-EXCLUSION-RULES-AFTER-CRS.conf{.example,}
#+END_SRC

- create the ModSecurity includes file that will list all Modsecurity rule files
/etc/nginx/modsecurity/modsecurity_includes.conf
#+BEGIN_EXAMPLE
include modsecurity.conf
include owasp-modsecurity-crs/crs-setup.conf
#+END_EXAMPLE

- include the REQUEST and RESPONSE lines
#+BEGIN_SRC sh
or f in $(ls -1 owasp-modsecurity-crs/rules/ | grep -E "^(RESPONSE|REQUEST)-.*\.conf$"); do \
  echo "include owasp-modsecurity-crs/rules/${f}" >> modsecurity_includes.conf; done
#+END_SRC

- edit the vhost file
/etc/nginx/conf.d/blog.example.com
#+BEGIN_EXAMPLE
root /var/www/blog.example.com;
    index index.php;

    modsecurity on;
    modsecurity_rules_file /etc/nginx/modsecurity/modsecurity_includes.conf;

    access_log syslog:server=unix:/dev/log vhost;
#+END_EXAMPLE

- testing the WAF
#+BEGIN_SRC sh
tail -f /var/log/nginx/modsecurity_audit.log
#+END_SRC
from a browseer type "http://blog.example.com/?params"><script>alert(1);</script>
  - this should log that a xss attack was attemptedk

** Setting up LEMP Stack with Wordpress using FastCGI Proxy
   
- add the "Software Collections" repo for php7
#+BEGIN_SRC sh
yum install -y centos-release-scl
yum update
#+END_SRC

- install php7 and required packages
#+BEGIN_SRC sh
yum install -y rh-php71-php rh-php71-php-fpm rh-php71-php-mysqlnd
#+END_SRC

- we need to let the nginx user have access and set up sockets instead of a port for simplicity
/etc/opt/rh/rh-php71/php-fpm.d/www.conf
#+BEGIN_EXAMPLE
; Set user and group
user = nginx
group = nginx
; Set to listen on a socket instead of port.
listen = /var/run/php-fpm.sock
; Set permissions on Unix socket.
listen.owner = nginx
listen.group = nginx
listen.mode = 0660
#+END_EXAMPLE

- start and enable php-fpm
#+BEGIN_SRC sh
systemctl start rh-php71-php-fpm
systemctl enable rh-php71-php-fpm
#+END_SRC

- add the mariadb repo to get the most stable up to date version
/etc/yum.repos.d/mariadb.repo
#+BEGIN_EXAMPLE
[mariadb]
name = Mariadb
baseurl = http://yum.mariadb.org/10.2/centos7-amd64
gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB
gpgcheck=1
#+END_EXAMPLE

- update the system
#+BEGIN_SRC sh
yum update
#+END_SRC

- add MariaDB with developer tools
#+BEGIN_SRC sh
yum install -y MariaDB-server MariaDB-client MariaDB-devel MariaDB-shared
#+END_SRC

- start and enable MariaDB
#+BEGIN_SRC sh
systemctl start mariadb
systemctl enable mariadb
#+END_SRC

- set up mariadb
#+BEGIN_SRC sh
mysql_secure_installation
#+END_SRC

- login to mariadb
#+BEGIN_SRC sh
mysql -u root -p
#+END_SRC

- create a wordpress database
#+BEGIN_EXAMPLE
> CREATE DATABASE wordpress;
> GRANT ALL PRIVILEGES ON wordpress.* TO wpuser@localhost IDENTIFIED BY "password";
> FLUSH PRIvILEGES;
#+END_EXAMPLE

- create directory to hold wordpress and pull down wp
#+BEGIN_SRC sh
mkdir /var/www/blog.example.com
wget -q -O - http://wordpress.org/latest.tar.gz | tar -xzf - --strip 1 -C /var/www/blog.example.com
#+END_SRC

- create wp configuration and add permissions
#+BEGIN_SRC sh
cp /var/www/blog.example.com/wp-config{-sample,}.php
chown -R nginx:nginx /var/www/blog.example.com
#+END_SRC

- edit to wp configuration file so that it knows about the database
/var/www/blog.example.com/wp-config.php
#+BEGIN_EXAMPLE
define('DB_NAME', 'wordpress');

/** MySQL database username */
define('DB_USER', 'wpuser');

/** MySQL database password */
define('DB_PASSWORD', 'p@ssw0rd');

/** MySQL hostname */
define('DB_HOST', 'localhost');
#+END_EXAMPLE

- the salts will also need to be added, these can be added by using the url in the config
#+BEGIN_EXAMPLE
define('AUTH_KEY',         '6VW:yG:KG]xlfZ=!Fogh -Ah6HORan0Ofb.vCKS:<]H9m$#ea+x2<kl/S.ZN+<+G');
define('SECURE_AUTH_KEY',  '1LtNz(+7i-tUg<=b/8hYaY,5n0{eH0xZi|2EMdDhx<0HF1I3IURcjDoY{v+iuI|*');
define('LOGGED_IN_KEY',    'qb+CoRB&m9gtx)GO!8/dqNmor]ocXEqly-U*.w&jdkg1a]BY/ByFVyQz-[^?u $2');
define('NONCE_KEY',        'j(&yUln(xFht>1$cn.RGM)w&30G 99AszB|5,RXc,ikxmU}M6$c]_i tAH<Y{1i.');
define('AUTH_SALT',        'T)QJ}O/a/mRYz?U;af!ZQ0`Mo{zVprr%=AYIT%@yfVc}pbrLC`9eQ~mkOn73>^%a');
define('SECURE_AUTH_SALT', '+I,~I`].d:3.VB|#&lsMux/cWb]Qe=S-bM&`xQ[rD:eWZ|2Q5G7( i8A8$Z5-T`o');
define('LOGGED_IN_SALT',   'HDa$<u)=csEUg!_+A#Bs#7|sTmhBNzm7{CA^1SfX!p|Y%xd-P|AZ>@l/!BXnt5.4');
define('NONCE_SALT',       'K,pM8b62Rw>a_[46olsBnqN)?IM8It/E2({2(Bqr7NK Ol+_f68ot=!;%+n6>S!|');
#+END_EXAMPLE
above is an example of what they will look like

- now need to create a new file for wp
/etc/nginx/conf.d/blog.example.com.conf
#+BEGIN_EXAMPLE
server {
    listen 80;
    server_name blog.example.com;

    root /var/www/blog.example.com;
    index index.php;
    
    location / {
        try_file $uri $uri/ $index.php?args;
    }
    
    location ~ \.php$ {
        fastcgi_index index.php;
        fastcgi_pass unix:/var/run/php-fpm.sock;
        include fastcgi_params;
	fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }
}
#+END_EXAMPLE

- test and reload nginx
#+BEGIN_SRC sh
nginx -t 
systemctl reload nginx
#+END_SRC

** MariaDB for LEMP

- installation (CentOS requires remi repo, but CentOS MariDB is the default)
#+BEGIN_SRC sh
wget http://rpms.famillecollet.com/enterprise/remi-release-6.rpm
rpm -Uvh remi-release-6.rpm
yum --enablerepremi-test --disablerepo=remi install compat-mysql55
#+END_SRC

- add maria repo
/etc/yum.repos.d/maria.repo
#+BEGIN_EXAMPLE
[mariadb]
name=MariaDB
baseurl=http://yum.mariadb.org/5.5/centos6-amd64
gpgkey=https://yum.mariadb.org/RPM-GPG-KEY-MariaDB
gpgcheck=1
#+END_EXAMPLE

- update the system
#+BEGIN_SRC sh
yum update
yum install MariaDB-devel MariaDB-cient MariaDB-server perl-DBD-MySQL
#+END_SRC

- start the service
#+BEGIN_SRC sh
service mysql start
#+END_SRC

- secure setup
#+BEGIN_SRC sh
mysql_secure_installation
#+END_SRC
this will run you through a set of questions that will allow you to set and remove passwords and users

- confirm that you can connect to db
#+BEGIN_SRC sh
mysql -u root -p
#+END_SRC

- restart php-fpm
#+BEGIN_SRC sh
service php-fpm restart
#+END_SRC
this has to be do as php-fpm my have a few problems recognizing the newly installed Mariadb

** php-fpm
   
- install php
#+BEGIN_SRC sh
yum install php
#+END_SRC

- create a php-fpm socket file
/etc/php-fpm.d/www.conf
#+BEGIN_EXAMPLE
listen = /var/run/php-fpm/www.sock
#+END_EXAMPLE

- add the correct ownership to the new sock file
#+BEGIN_SRC sh
chown nginx:nginx /var/run/php-fpm/www.sock
#+END_SRC

- start and enable php-fpm
#+BEGIN_SRC sh
chkconfig php-fpm on
service php-fpm start
#+END_SRC

** Proxying a uWSGI Application

- creating the configuration file
/etc/nginx/conf.d/notes.example.com.conf (the example application provided by LA)
#+BEGIN_EXAMPLE
server {
    listen 80;
    server_name notes.example.com;

    location /static {
        root /var/www/notes.example.com;
    }

    location / {
        include uwsgi_params;
        uwsgi_pass unix:/var/run/uwsgi/notes.sock;
    }
}
#+END_EXAMPLE
   
- test and reload nginx
#+BEGIN_SRC sh
nginx -t
systemctl reload nginx
#+END_SRC

- if SELinux is enabled then you will need to set the correct contexts
#+BEGIN_SRC sh
grep nginx /var/log/audit/audit.log | audit2allow -m nginx
#+END_SRC
this will show us the policy file that will be created based on the errors in the audit file

- to create the policy file
#+BEGIN_SRC sh
grep nginx /var/log/audit/audit.log | audit2allow -M nginx
#+END_SRC
this will generate the policy file (.pp data, .te this is a plain text file of .pp will inplement)

- implement the policy file
#+BEGIN_SRC sh
semodule -i nginx.pp
semodule --enable nginx
restorecon -Rv /var/www/example.com/
restorecon -Rv /run/uwsgi/
#+END_SRC

** Simple Caching for Static Content (php)
Though this is for php, it is also available for most other languages

- setting fastcgi_cache_path in the configuration
/etc/ngnx/conf.d/blog.example.com.conf
#+BEGIN_EXAMPLE
fastcgi_cache_path /var/cache/nginx/blog levels=1:2
                   keys_zone=blog:10m size=1g inactive=60m;
server {
    listen 80;
    server_name blog.example.com;

    root /var/www/blog.example.com;
    index index.php;
    
    fastcgi_cache_key $scheme$request_method$host$request_uri; # this is required by both fastcgi and uwsgi
    
    location / {
        try_file $uri $uri/ $index.php?args;
    }
    
    location ~ \.php$ {
        fastcgi_index index.php;
        fastcgi_pass unix:/var/run/php-fpm.sock;
        fastcgi_cache blog;
        fastcgi_cache_valid 60m 
        include fastcgi_params;
	fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }
}
#+END_EXAMPLE
/var/cache/nginx/blog - specifies the directory to store the cached objects
levels=1:2 - specifies the number of subdirectory levels used in the cache. This is the recommended setting, yet not the default
keys_zone=blog:10m - Allows us to specify the name of the cache and the size of the memory space that will hold the keys and metadata information. The name and size of the lookup table so NGINX can quickly know if a request is a cache hit or miss
max_size=1g - Defines the maximum amount of storage we’re allowing NGINX to use for this cache. If not set it will keep caching new keys only limited by storage
inactive=60m - Defines the maximum cache lifetime of an item if it’s not accessed again. The cache will be populated on the first hit, and then after that, it will have 60 minutes to receive another request or the item will be removed from the cache

- adding additional cache header
#+BEGIN_EXAMPLE
    location ~ \.php$ {
        add_header X-Cache-Status $upstream_cache_status;
        fastcgi_index index.php;
        fastcgi_pass unix:/var/run/php-fpm.sock;
        fastcgi_cache blog;
        fastcgi_cache_valid 60m 
        include fastcgi_params;
	fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }
#+END_EXAMPLE
this will allow us to know if the request was a cache hit or miss from the browser's response information


- Not Caching Content
We wouldn't want information that is in the /wp-admin to be cached as it's dynamic
#+BEGIN_EXAMPLE
fastcgi_cache_path /var/cache/nginx/blog levels=1:2
                   keys_zone=blog:10m max_size=1g inactive=60m;

server {
    listen 80;
    server_name blog.example.com;

    root /var/www/blog.example.com;
    index index.php;

    fastcgi_cache_key $scheme$request_method$host$request_uri;

    set $skip_cache 0;

    if ($request_uri ~* "/wp-admin") {
        set $skip_cache 1;
    }

    location / {
        try_files $uri $uri/ /index.php?$args;
    }

    location ~ \.php$ {
        add_header X-Cache-Status $upstream_cache_status;
        fastcgi_index index.php;
        fastcgi_pass unix:/var/run/php-fpm.sock;
        fastcgi_cache_bypass $skip_cache;
        fastcgi_no_cache $skip_cache;
        fastcgi_cache blog;
        fastcgi_cache_valid 60m;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
    }
}
#+END_EXAMPLE
if wp-admin is accessed $skip_cache is set to 1 and fastcgi_no_cache and fastcgi_cache_bypass will interpret this


- Purging the Cache
#+BEGIN_SRC sh
rm -rf /var/cache/nginx/blog
#+END_SRC

** Basic Rewrites
   
- change from /forum to /forums on site

#+BEGIN_EXAMPLE
server {
	listen 80;

	index index.html index.htm index.php;
	
	server_name myexample.local www.myexample.local;

	location /forum {
		rewrite ^/forum/(.*)$ http://www.myexample.local/forums/$1 permanent;
	}

	location / {
		root /var/www/html/myexample
	}
	
}

#+END_EXAMPLE

** Use Rewrite Rules

- remove the suffix from pages (this example removes .html from files and
#+BEGIN_EXAMPLE
server {
    listen 80 default_server;
    listen 443 ssl;
    server_name _;
    root /var/www/html;
    
    ssl_certificate /etc/nginx/ssl/public.pem
    ssl_certificate_key /etc/nginx/ssl/private.key
    
    # Remove the .html from files
    rewrite ^(/.*)\.html(\?.*)?$ $1$2 redirect;
    # this removes any trailing / on requests
    rewrite ^/(.*)/$ /$1 redirect;
    
    location / {
        try_files $uri/idex.html $uri.html $uri/ $uri =404;
    }

    location = /admin.html{
        auth_basic "Login Required";
        auth_basic_user_file /etc/nginx/.htpasswd;
        try_files $uri/idex.html $uri.html $uri/ $uri =404;
    }
    
    error_page 404 /404.html;
    error_page 500 501 502 503 504 /50x.html;
}
#+END_EXAMPLE

- test and reload
#+BEGIN_SRC sh
nginx -t
systemctl reload nginx
#+END_SRC

** Check rewrites in nginx.conf
#+BEGIN_SRC sh
grep -i rewrite /etc/nginx/conf.d/tinygreenpc.com.conf | wc -l
#+END_SRC

** Vhost File
   
- adding a virtual host
/etc/nginx/vhost.d/myexample.local.conf
#+BEGIN_EXAMPLE
server {
	listen 80;

	root /var/www/html/myexample;
	index index.html index.htm index.php;
	
	server_name myexample.local www.myexample.local;
}
#+END_EXAMPLE

- create the myexample.local files
#+BEGIN_SRC sh
mkdir -p /var/www/html/myexample
echo "This is our new Config for myexample.local" > /var/www/html/myexample/index.html
#+END_SRC

- test the new config
#+BEGIN_SRC sh
nginx -t
#+END_SRC

- restart the service
#+BEGIN_SRC sh
service nginx restart
#+END_SRC
both the new myexample.local and the default weeb page will be viewable

** Upstream Module
Placing of the Nginx server infront of another server (example apllication server, such as node.js), proxy the connection.

- create a new vhost file
/etc/nginx/vhost.d/mynode.local.conf
#+BEGIN_EXAMPLE
upstream mynode {
	server localhost:8888;
}

server {
	server_name www.mynode.local mynode.local;

	location / {
		proxy_pass http://mynode;
	}
}
#+END_EXAMPLE

- restart the service
#+BEGIN_SRC sh
service nginx restart
lynx http://www.mynode.local
#+END_SRC

The advantage of using nginx it can provide full web server functionality (logging), where maybe the application server could be lacking

** Basic Load Balancing

- edit the vhost file
/etc/nginx/vhost.d/mynode.local.conf
#+BEGIN_EXAMPLE
upstream mynode {
	server localhost:8888;
	server localhost:8889;
}

server {
	server_name www.mynode.local mynode.local;

	location / {
		proxy_pass http://mynode;
	}
}
#+END_EXAMPLE
- the node.js applicaition, or whatever application or site will have to be configured and setup to run on both ports
  
- test and restart
#+BEGIN_SRC sh
nginx -t
service nginx restart
#+END_SRC

*** Weights
#+BEGIN_EXAMPLE
upstream mynode {
	server localhost:8888 weight=1;
	server localhost:8889 weight=4;
}

server {
	server_name www.mynode.local mynode.local;

	location / {
		proxy_pass http://mynode;
	}
}
#+END_EXAMPLE
weights are proportional, weight=4 should get four times as much traffic as weight=1

** Load Balancing to Multiple Servers
here we are using the same server using different applications

- edit conf.d/photos.example.conf   
#+BEGIN_EXAMPLE
upstream photos {
    server 127.0.0.1:3000;
    server 127.0.0.1:3100;
    server 127.0.0.1:3101;
}

server {
    listen 80;
    server_name photos.example.com;

    client_max_body_size 5m;

    location / {
        proxy_pass http://photos;
        proxy_http_version 1.1;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Real-IP  $remote_addr;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }

    location ~* \.(js|css|png|jpe?g|gif) {
        root /var/www/photos.example.com;
    }
}
#+END_EXAMPLE
this would use the round robin method as it is the default

- the three lines commented out are the other LB delivery methods
#+BEGIN_EXAMPLE
upstream photos {
    #leat_conn;
    #ip_hash;
    #hash $request_uri;

    server 127.0.0.1:3000;
    server 127.0.0.1:3100;
    server 127.0.0.1:3101;
}
#+END_EXAMPLE

- priorities servers with weights
#+BEGIN_SRC sh
upstream photos {
    server 127.0.0.1:3000 weight=2;
    server 127.0.0.1:3100;
    server 127.0.0.1:3101;
}
#+END_SRC
- This would make server using port 3000 recieve twice as many connections as the other two servers(2 out of 4).
- By default weight is 1.
  
- Passive Health Cheking
#+BEGIN_SRC sh
upstream photos {
    server 127.0.0.1:3000;
    server 127.0.0.1:3100 max_fails=3 fail_timeout=20s;
    server 127.0.0.1:3101 max_fails=3 fail_timeout=20s;
}
#+END_SRC
if you have 3 failures within 20s Nginx will mark the server as down

** Location Directive
/etc/nginx/vhost.d/myexample.local.conf
- nginx allows different content to be served by the set URI
#+BEGIN_EXAMPLE
server {
	listen 80;

	index index.html index.htm index.php;
	
	server_name myexample.local www.myexample.local;

	location / {
		root /var/www/html/myexample
	}
	
	location /google/ {
		proxy_pass http://www.google.com;
	}
	
	location /images/ {
		root /var/www/html/images;
	}
}

server {
	listen 443;

	root /var/www/html/myexample;
	index index.html index.htm index.php
	
	server_name www.myexample.local myexample.local
	
	ssl on;
	ssl_certificate /etc/nginx/ssl/server.crt;
	ssl_certificate_key /etc/nginx/ssl/server.key;
}
#+END_EXAMPLE
- First location  - is just reimplementing the root variable
- Second location - is just passing the request off to www.google.com
- Third location  - is an image directory. 
  - This means it can be shared across sites.

** Return Directive
   
- this allows for return codes to be leveraged to provide functionality
  - provide an error code
  - provide a redirect
   
#+BEGIN_EXAMPLE
server {
	listen 80;

	index index.html index.htm index.php;
	
	server_name myexample.local www.myexample.local;

	# this will redirect /forum to google.com
	location /forum {
		return 301 http://www.google.com;
	}

	location / {
		root /var/www/html/myexample
	}
	
}

#+END_EXAMPLE

** Custom Error Pages
   
- add the new error page
#+BEGIN_SRC sh
echo "This is our custom content does not exist page" > /var/www/html/myexample/404.html
#+END_SRC

- across all sites change in the nginx.conf
  
- for specific virtual hosts add to the vhost file
#+BEGIN_EXAMPLE
server {
	listen 80;

	root /var/www/html/myexample;
	index index.html index.htm index.php;
	
	server_name myexample.local www.myexample.local;
	
	error_page 404 = /404.html;
	location = /403.html {
		root /var/www/html/myexample;
		internal;
	}
}

#+END_EXAMPLE

- internal - only for nginx's use

** Logging
   
- Error Logs 
/etc/nginx/nginx.conf
#+BEGIN_EXAMPLE
error_log /var/log/nginx/error.log;
#+END_EXAMPLE
this will log all error messages

- setting error logging level
#+BEGIN_EXAMPLE
error_log /var/log/nginx/error.log notice;
error_log /var/log/nginx/error.log info;
#+END_EXAMPLE
these two will report at different levels of logging

- Access Logs
  - this is defined in the http format
    #+BEGIN_EXAMPLE
    log_format main '$remote_addr - $remote_user [$time_local] "$request" '
                    '$status $body_bytes_sent "$http_referer" '
                    '"$http_user_agent" "$http_x_forwarded_for"';	

    access_log /var/log/nginx/access.log main;
    #+END_EXAMPLE
    
- Both error and access logs set like this will log for all domains configured
  
- Configure Virtual Hosts
  
- add error_log and access_log to the vhost file
#+BEGIN_EXAMPLE
server {
	listen 80;

	root /var/www/html/myexample;
	index index.html index.htm index.php;
	
	server_name myexample.local www.myexample.local;
	
	access_log /var/log/nginx/myexample.access.http.log;
	error_log /var/log/nginx/myexample.error.http.log;
}

server {
	listen 443;

	root /var/www/html/myexample;
	index index.html index.htm index.php
	
	server_name www.myexample.local myexample.local

	access_log /var/log/nginx/myexample.access.https.log;
	error_log /var/log/nginx/myexample.error.https.log;
	
	ssl on;
	ssl_certificate /etc/nginx/ssl/server.crt;
	ssl_certificate_key /etc/nginx/ssl/server.key;
}
#+END_EXAMPLE

- for the logs to become active restart nginx
#+BEGIN_SRC sh
service nginx restart
#+END_SRC

*** Custom Log Levels
    
- Setting compression and buffering
#+BEGIN_SRC 
server {
	listen 80;

	root /var/www/html/myexample;
	index index.html index.htm index.php;
	
	server_name myexample.local www.myexample.local;
	
	access_log /var/log/nginx/myexample.access.http.log combined buffer=32k;
	error_log /var/log/nginx/myexample.error.http.log;
}
#+END_SRC
- The buffer size must not exceed the size of an atomic write to a disk file. For FreeBSD this size is unlimited.
  - usually 32k on linux
  
- 8 Logging Levels
  - emerg: Emergency situations where the system is in an unusable state.
  - alert: Severe situation where action is needed promptly.
  - crit: Important problems that need to be addressed.
  - error: An Error has occurred. Something was unsuccessful.
  - warn: Something out of the ordinary happened, but not a cause for concern.
  - notice: Something normal, but worth noting has happened.
  - info: An informational message that might be nice to know.
  - debug: Debugging information that can be useful to pinpoint where a problem is occurring.
#+BEGIN_EXAMPLE
error_log /var/log/nginx/myexample.error.http.log warn;
#+END_EXAMPLE
this would log all emerg, alert, crit, error and warn messages

*** Custom Access Log Format
    
#+BEGIN_SRC 
server {
	listen 80;

	root /var/www/html/myexample;
	index index.html index.htm index.php;
	
	server_name myexample.local www.myexample.local;
	
	log_format myAccessFormat 'Remote IP: $remote_addr - Time Request: $time_local - Browser Agent: $http_user_agent';
	
	access_log /var/log/nginx/myexample.access.http.log myAccessFormat buffer=32k;
	error_log /var/log/nginx/myexample.error.http.log;
}
#+END_SRC
- the access log will now use the myAccessFormat to record our log
  
** Blocking Ips
/etc/nginx/nginx.conf   
#+BEGIN_EXAMPLE
include blockips.conf;
#+END_EXAMPLE

/etc/nginx/blockips.conf
#+BEGIN_EXAMPLE
deny 72.34.121.10;
#+END_EXAMPLE
any requests from this ip should throw a 403 denied

- test the configuration and restart the service
#+BEGIN_SRC sh
nginx -t
service nginx restart
#+END_SRC

- adding for domain only
#+BEGIN_EXAMPLE
server {
	listen 80;

	index index.html index.htm index.php;
	
	server_name myexample.local www.myexample.local;
	
	log_format myAccessFormat 'Remote IP: $remote_addr - Time Request: $time_local - Browser Agent: $http_user_agent';
	
	access_log /var/log/nginx/myexample.access.http.log myAccessFormat buffer=32k;
	error_log /var/log/nginx/myexample.error.http.log;
	
	location / {
		root /var/www/html/myexample;
		
		deny 72.129.45.10;
	}
}
#+END_EXAMPLE
- the global block list has precedence over the domain block and allow

** Optimization of Nginx
   
- Setting the number of processors
/etc/nginx/nginx.conf
#+BEGIN_EXAMPLE
worker_processes 2;
#+END_EXAMPLE
- this is normally set to the number of available cores
- if set higher than number of caores, it will not damage the system just run at the max number of cores
  
- Setting the number of worker connections
/etc/nginx/nginx.conf
#+BEGIN_EXAMPLE
worker_connections 1024;
#+END_EXAMPLE
- this is the number of connections that can be handled
  
*** Buffers
- client_buffer_size 

- client_header_buffer 
  - 1024
  
- client_max_body_size
  - if exceeded then a 413 - Payload too large - previously know as a "Request Entity Too Large"

/etc/nginx/nginx.conf
#+BEGIN_EXAMPLE
http {
	...			
	client_body_buffer_size 10k;	
	client_header_buffer_size 1k;
	client_max_body_size 8m; # support up to max memory, but need to account for underlying OS
	large_client_header_buffers 2 1k; # 2 at 1k
}
#+END_EXAMPLE

*** Timeouts
- client_body_timeout
  - how long the server waits until it kills the connection
    
- client_header_timeout
  
- keep_alive_timeout
  
- send_timeout
  
/etc/nginx/nginx.conf
#+BEGIN_EXAMPLE
http {
	...	
	client_body_timeout 12; # 12 seconds is consider the max for a website to render, worst case (should be 3 - 5 secs)
	client_header_timeout 12;
	keepalive_timeout 15;
	send_timeout 10;
}
#+END_EXAMPLE

** Content Compressions and Decompression
ngx_http_gzip_module
ngx_http_gunzip_module

/etc/nginx/nginx.conf
#+BEGIN_EXAMPLE
gzip on;
# disable cmpression for Internet Explorer 6 (old browser), there are more options in the docs
gzip_disable msie6;
# Specify that we only want to compress responses from proxied servers if we normally wouldn’t cache them
gzip_proxied no-cache no-store private expired auth;
# the types of content that we want to compress
gzip_types text/plain text/css application/x-javascript application/javascript application/xml application/xml+rss text/javascript image/x-icon image/bmp image/svg+xml
# by default this is set to 20 bytes, this may casue the cpu to become to occupied with compression
gzip_min_length 1024;
# Adds a Vary: Accept-Encoding header. This tells intermediate caches (like CDNs) to treat the compressed and uncompressed version of the same resource as 2 separate entities
gzip_vary on;
# this allows decompression server end
gunzip on;
#+END_EXAMPLE
jpg can't be compressed more that it already is (trying to will waste cpu cycles).

** Workers and Connections

- worker processors has an "auto" value that means nginx will automatically determine the cpu number and set that as the worker process
#+BEGIN_EXAMPLE
worker_processes auto;
#+END_EXAMPLE

- connections is a little more tricky as it depends on the content that is being delivered, this can be tweaked over time
#+BEGIN_EXAMPLE
worker_connections 2048;
#+END_EXAMPLE
better to have number too high than too low, better to serve connections slow than dropping

- we may also run into the problem of having too may connections for the OS
#+BEGIN_SRC sh
su -s /bin/sh -c "ulimit -Sn"
su -s /bin/sh -c "ulimit -Hn"
#+END_SRC
this tells us our hard and soft limits 

- we can edit our conf to reflect these hard and soft limits
#+BEGIN_SRC sh
worker_rlimit_nofile 4096;
#+END_SRC
4096 would be the limit that is set by the OS


- kkeepalive_request sets the number of requests that can be sent over a single connection
#+BEGIN_SRC sh
keepalive_reuests 100; #100 is the default
#+END_SRC
if you had a lot of images over 100 on a page, this would be too low, but 100 is usually fine

** HTTP/2
   
- you have to be serving content over ssl
#+BEGIN_EXAMPLE
server {
    listen 443 ssl http2 default_server;
    ssl_certificate /etc/nginx/ssl/public.pem;
    ssl_certificate_key /etc/nginx/ssl/private.key;
    
    root /var/www/html;
    
}
#+END_EXAMPLE

** PageSpeed by Google
HomePage: https://developers.google.com/speed/  

- build pagespeed
#+BEGIN_SRC sh
cd /opt
bash <(curl -f -L -sS https://ngxpagespeed.com/install) -b . --dynamic-module --ngx-pagespeed-version latest-stable
cd nginx-1.12.2 # this is the source code for nginx
./configure --with-compat --add-dynamic-module=../incubator-pagespeed-ngx-latest-stable
make modules
cp objs/ngx_pagespeed.so /etc/nginx/modules/
#+END_SRC

/etc/nginx/nginx.conf
#+BEGIN_EXAMPLE
user  nginx;
worker_processes  1;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

# Load ModSecurity dynamic module
load_module /etc/nginx/modules/ngx_http_modsecurity_module.so;

# Load PageSpeed dynamic module
load_module /etc/nginx/modules/ngx_pagespeed.so;
#+END_EXAMPLE

/etc/nginx/conf.d/blog.example.com
#+BEGIN_EXAMPLE
astcgi_cache_path /var/cache/nginx/blog levels=1:2
                   keys_zone=blog:10m max_size=1g inactive=60m;
server {
    listen 80;
    server_name blog.example.com;
    root /var/www/blog.example.com;
    index index.php;
    modsecurity on;
    modsecurity_rules_file /etc/nginx/modsecurity/modsecurity_includes.conf;

# Before - 11 requests 437.29 KB / 268.15 KB transferred Finish: 584 ms

pagespeed on;

# Needs to exist and be writable by nginx.  Use tmpfs for best performance.
pagespeed FileCachePath /var/cache/nginx/ngx_pagespeed_cache;

# Ensure requests for pagespeed optimized resources go to the pagespeed handler
# and no extraneous headers get set.
location ~ "\.pagespeed\.([a-z]\.)?[a-z]{2}\.[^.]{10}\.[^.]+" {
  add_header "" "";
}
location ~ "^/pagespeed_static/" { }
location ~ "^/ngx_pagespeed_beacon$" { }

    access_log /var/log/nginx/access.log vhost;

    fastcgi_cache_key $scheme$request_method$host$request_uri;

    # Configuration continued ...
#+END_EXAMPLE

- makesure that the ngx_pagespeed_cache directory is created
#+BEGIN_SRC sh
mkdir -p /var/cache/nginx/ngx_pagespeed_cache
chown -R nginx:nginx /var/cache/nginx/ngx_pagespeed_cache
nginx -t
systemctl reload nginx
#+END_SRC

** Speed up Nginx Performance with Ngx_Pagespeed on CentOS 7
1. These tools will be required
[[file://home/crito/Pictures/org/ngx_pagespeed_1.png]]

2. Pull the source code for Nginx
[[file://home/crito/Pictures/org/ngx_pagespeed_2.png]]

3. Next download the ngx_pagespeed source files unzip compressed files
[[file://home/crito/Pictures/org/ngx_pagespeed_3.png]]

4. Get the opmitized libraries to compile with Nginx
[[file://home/crito/Pictures/org/ngx_pagespeed_4.png]]

5. Configure the Nginx for compilation
[[file://home/crito/Pictures/org/ngx_pagespeed_5.png]]

6. Next compile and install
#+BEGIN_SRC sh
make
make install
#+END_SRC

7. Create the need symbolic links
[[file://home/crito/Pictures/org/ngx_pagespeed_6.png]]   

8. Create the systemd unit file
[[file://home/crito/Pictures/org/ngx_pagespeed_7.png]]

you need to make note the location of the pid file and the Nginx binary  
[[file://home/crito/Pictures/org/ngx_pagespeed_8.png]]

9. Test that the systemd unit file works
#+BEGIN_SRC sh
systemctl start nginx
systemctl enable nginx
systemctl status nginx
#+END_SRC

10. Create a directory where the module is to cache the files for the site
#+BEGIN_SRC sh
mkdir -p /var/ngx_pagespeed_cache
chown -R nobody:nobody /var/ngx_pagespeed_cache
#+END_SRC

11. Enable the module by adding the following lines to the server block in the nginx.conf
[[file://home/crito/Pictures/org/ngx_pagespeed_10.png]]

12. Check that the config file is error free
#+BEGIN_SRC sh
nginx -t
#+END_SRC

13. Now restart the service for the changes to take effect
#+BEGIN_SRC sh 
systemctl restart nginx.service
#+END_SRC

14. Test that Nginx is using Pagespeed
#+BEGIN_SRC sh
curl -I -p http://localhost
#+END_SRC
if Ngx_Pagespeed is enabled you should see the X-Page-Speed header implemented
[[file://home/crito/Pictures/org/ngx_pagespeed_11.png]]

*** Example Nginx with Ngx_Pagespeed enabled
#+BEGIN_EXAMPLE
#user  nobody;
worker_processes  1;
#error_log  logs/error.log;
#error_log  logs/error.log  notice;
#error_log  logs/error.log  info;
#pid        logs/nginx.pid;
events {
worker_connections  1024;
}
http {
include       mime.types;
default_type  application/octet-stream;
#log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
#                  '$status $body_bytes_sent "$http_referer" '
#                  '"$http_user_agent" "$http_x_forwarded_for"';
#access_log  logs/access.log  main;
sendfile        on;
#tcp_nopush     on;
#keepalive_timeout  0;
keepalive_timeout  65;
#gzip  on;
server {
listen       80;
server_name  localhost; 
#charset koi8-r;
#access_log  logs/host.access.log  main;
# Pagespeed main settings
pagespeed on;
pagespeed FileCachePath /var/ngx_pagespeed_cache;
# Ensure requests for pagespeed optimized resources go to the pagespeed
# handler and no extraneous headers get set.
location ~ "\.pagespeed\.([a-z]\.)?[a-z]{2}\.[^.]{10}\.[^.]+" { add_header "" ""; }
location ~ "^/ngx_pagespeed_static/" { }
location ~ "^/ngx_pagespeed_beacon" { }
location / {
root   html;
index  index.html index.htm;
}
#error_page  404              /404.html;
# redirect server error pages to the static page /50x.html
#
error_page   500 502 503 504  /50x.html;
location = /50x.html {
root   html;
}
# proxy the PHP scripts to Apache listening on 127.0.0.1:80
#
#location ~ \.php$ {
#    proxy_pass   http://127.0.0.1;
#}
# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000
#
#location ~ \.php$ {
#    root           html;
#    fastcgi_pass   127.0.0.1:9000;
#    fastcgi_index  index.php;
#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
#    include        fastcgi_params;
#}
# deny access to .htaccess files, if Apache's document root
# concurs with nginx's one
#
#location ~ /\.ht {
#    deny  all;
#}
}
# another virtual host using mix of IP-, name-, and port-based configuration
#
#server {
#    listen       8000;
#    listen       somename:8080;
#    server_name  somename  alias  another.alias;
#    location / {
#        root   html;
#        index  index.html index.htm;
#    }
#}
# HTTPS server
#
#server {
#    listen       443 ssl;
#    server_name  localhost;
#    ssl_certificate      cert.pem;
#    ssl_certificate_key  cert.key;
#    ssl_session_cache    shared:SSL:1m;
#    ssl_session_timeout  5m;
#    ssl_ciphers  HIGH:!aNULL:!MD5;
#    ssl_prefer_server_ciphers  on;
#    location / {
#        root   html;
#        index  index.html index.htm;
#    }
#}
}
#+END_EXAMPLE

** Too Many Open Files Error And Solution
[[http://www.cyberciti.biz/faq/linux-unix-nginx-too-many-open-files/]]

** Check to see what sites are running on 443
#+BEGIN_SRC sh
grep 443 /etc/nginx/conf.d/*
#+END_SRC
or
#+BEGIN_SRC sh
httpd -S 2>&1|grep "port 443 name"|grep -v =hostname=| awk {'print $4'}httpd -S 2>&1|grep "port 443 name"|grep -v =hostname=| awk {'print $4'}
#+END_SRC

** If a site randomy returns 403's and then 200 when curling

Add Options +Indexes to the .htaccess file and you will get 200 on curls

[[https://stackoverflow.com/questions/10365520/error-directory-index-forbidden-by-options-directive][Stackoverflow - error directory index forbidden]]

* Lecture
** PHP-FPM - Andrew Lechowicz
yt: https://www.youtube.com/watch?v=a4A0HzAEiRo

- php-FPM is an altrnative to php-fastcgi

- FastCGI
  - binary protocal for interfacing interactive programs with a web server
  - an improvement on CGI
  - reduces the overhead on the server
  - a seperation of web server and application
  - doesn't create a new process for each request(CGI would)
  - Uses persistent processesto handle to handle a series of requests
  - the processors are owned by FastCGI server not the web server 
    
- PHP-FPM
  - is all of FastCGI plus
  - included in 5.5.3
  - emergency restart - will gracefully shutdown cgi process
  - support for "slowlog"
  - ability to start workers with different uid/gid/chroot environment and different php.ini
    
- Why Use PHP-FPM
  - seperates PHP from the web server
  - use less resources than mod_php 

- Installation
#+BEGIN_SRC sh
apt-get update
apt-get install php5-fpm nginx
#+END_SRC

- configure nginx
/etc/nginx/sites-available/default
#+BEGIN_EXAMPLE
Server {
  listen 80;
  server_name example.com;
  
  root /var/www/example.com
  index index.php;

  location / {
    try_files $uri $uri/ /index.php?$args;
  }

  location ~ \.php$ {
    try_files $uri =404;
    include /usr/local/etc/nginx/fastcgi_paras;
    fastcgi_pass	127.0.0.1:9000;
    fastcgi_index	index.php
    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
  }
#+END_EXAMPLE
- add "index.php"
- change server_name to IP
- uncomment lines in 'location ~ \.php$'
  
- restart nginx
#+BEGIN_SRC sh
nginx -s restart
#+END_SRC

- configure php-fpm
/etc/php5/fpm/php.ini
  - ensure that "cgi.fix_pathinfo" is set to 0
    
/etc/php5/fpm/pool.d/www.conf
  - change "Listen" value from "127.0.0.1:9000" to "/var/run/php5-fpm.sock"
    
- restart php-fpm
#+BEGIN_SRC sh
service php5-fpm restart
#+END_SRC

- create and index.php file with a phpinfo() call;
#+BEGIN_SRC sh
echoo 2<?php phpinfo() ?>" > /usr/share/nginx/www/index.php
#+END_SRC

* Tutorial
** Linux Academy Lab - Nginx installation of SSL Certificate
   LabGuide: [[file://home/crito/Documents/Linux/Labs/Nginx-ssl.pdf][Nginx and Self Signed SSL Certificates]]

* Books
[[file://home/crito/Documents/SysAdmin/Web/Nginx/Complete_NGINX_Cookbook.pdf][Complete Nginx Cookbook]]
[[file://home/crito/Documents/SysAdmin/Web/Nginx/Mastering_Nginx.pdf][Mastering Nginx]]
[[file://home/crito/Documents/SysAdmin/Web/Nginx/Nginx-From_Beginner_to_Pro.pdf][Nginx - From Beginner to Pro]]
[[file://home/crito/Documents/SysAdmin/Web/Nginx/Nginx-HTTP_Server.pdf][Nginx - HTTP Server]]
[[file://home/crito/Documents/SysAdmin/Web/Nginx/Nginx_Essentials.pdf][Nginx - Essentials]]
[[file://home/crito/Documents/SysAdmin/Web/Nginx/Nginx_HTTP_Server_3ed.pdf][Nginx - HTTP Server 3ed]]
[[file://home/crito/Documents/SysAdmin/Web/Nginx/Nginx_Module_Extension.pdf][Nginx Module Extension]]

* Links
[[https://www.linode.com/docs/websites/nginx/how-to-configure-nginx][How To Configure Nginx - Linode]]
[[https://www.digitalocean.com/community/tutorials/understanding-nginx-server-and-location-block-selection-algorithms][Understanding Ngin Server and Location Block Selection Algorithms]]
[[https://www.tecmint.com/nginx-web-server-security-hardening-and-performance-tips/][Nginx Securtiy Hardening and Performance tips - Techmint]]
