#+TAGS: virtualization container docker linux_containers


* Docker
HomePage: [[https://www.docker.com/][docker.com]]
CheatSheet: [[https://github.com/wsargent/docker-cheat-sheet][github.com/docker-cheat-sheet]]
* Files
/var/lib/docker         - data and metadata store
/var/lib/containers     - long hashes are the container names these contain data on the conatiners
/var/lib/docker/image   - 
/var/lib/docker/network -
/var/lib/docker/overlay -
/var/lib/docker/plugins -
/var/lib/docker/swarm   - 
/var/lib/docker/tmp     -
/var/lib/docker/trust   -
/var/lib/docker/volumes -
/var/run/docker.pid
/var/run/docker.sock
* Cmds
- docker-compose

* Tools
- [[file://home/crito/org/tech/virt_and_cloud/kubernetes.org][Kubernetes]]
- [[https://github.com/Yelp/dockersh][Dockersh]]
- [[https://github.com/kevana/ui-for-docker][DockerUI]]
- [[https://github.com/shipyard/shipyard][Shipyard]]
- [[https://github.com/gliderlabs/logspout][Logspout]]
** [[https://github.com/jpetazzo/dind][DIND - Docker Inside Docker]] 

* Description
* Usage
** Start and Stop
*** Start
- starting a docker container that is running a command
#+BEGIN_SRC sh
docker run -itd ubuntu:xenial /bin/bash
#+END_SRC
i - interactive
t - 
d - detattched

- start the container but without specifying the cmd
#+BEGIN_SRC sh
docker start nginx:latest
#+END_SRC

*** Stop
#+BEGIN_SRC sh
docker stop $DOCKER_ID
#+END_SRC

*** Restart
#+BEGIN_SRC sh
docker restart $DOCKER_ID
#+END_SRC

*** Pause
#+BEGIN_SRC sh
docker pause $DOCKER_ID
#+END_SRC

*** Unpause
#+BEGIN_SRC sh
docker unpause $DOCKER_ID
#+END_SRC

*** Kill
Sends SIGKILL to a running container    
#+BEGIN_SRC sh
docker kill $DOCKER_ID
#+END_SRC

*** Run single cmd with a container
#+BEGIN_SRC sh
docker run ubuntu:xenial /bin/echo "Hello from this container"
#+END_SRC
once the container has run the command it will exit
** List running containers
#+BEGIN_SRC sh
docker ps $DOCKER_ID
#+END_SRC

** Get logs from container
#+BEGIN_SRC sh
docker logs $DOCKER_ID
#+END_SRC
this will provide a print out of the activity in the container

** Looks at all the info on a container
#+BEGIN_SRC sh
docker ps $DOCKER_ID
#+END_SRC

** Shows public facing port of container
#+BEGIN_SRC sh
docker port $DOCKER_ID
#+END_SRC

** Clean up non-used network interfaces
#+BEGIN_SRC sh
docker network prune
#+END_SRC

** Installation on CentOS 7
- first create a repo file to /etc/yum.repos.d/docker.repo
#+BEGIN_EXAMPLE
[dockerrepo]
name=Docker Repository
baseurl=https://yum.dockerproject.org/repo/main/centos/7/
enabled=1
gpgcheck=1
gpgkey=https://yum.dockerproject.org/gpg
#+END_EXAMPLE

- now update the system
#+BEGIN_SRC sh
yum update
#+END_SRC
care should be taken if this is a production server as it will update the whole system

- install the docker-engine
#+BEGIN_SRC sh
yum install docker-engine
#+END_SRC

- enable, start, and confirm status of docker
#+BEGIN_SRC sh
systemctl enable docker
systemctl start docker
systemctl status docker
#+END_SRC

- check that you are able to connect to the docker deamon
#+BEGIN_SRC sh
docker --version
#+END_SRC

- any users that are to use docker will need to be part of the docker group
#+BEGIN_SRC sh
usermod -a -G docker user
#+END_SRC
this is due to the user will need access to /var/run/docker.socket that has privs of root:docker

- confirm that the user can connect to the daemon
#+BEGIN_SRC sh
docker --version
#+END_SRC
if this fails exit the session and re-enter, this should resolve the problem

- good quick test is to pull in a simple image to docker as user
#+BEGIN_SRC sh
docker run hello-world
#+END_SRC
this will pull the hello-world image from docker hub, print a blurb and exit

** Show Docker information
- show version short
#+BEGIN_SRC sh
docker --version
#+END_SRC

- show version full
#+BEGIN_SRC sh
docker version
#+END_SRC

- show detailed information about the daemon
#+BEGIN_SRC sh
docker info
#+END_SRC
** Interacing with a running instance
- attach, makesure that a shell is available, or you'll attach to the processes
#+BEGIN_SRC sh
docker attach name_of_container
#+END_SRC
this method will cause the container to exit when you exit

- exec, this command always for any command to be run by against the container
#+BEGIN_SRC sh
docker exec ecstatic_yonath /bin/cat /etc/profile
#+END_SRC
this will print to the screen the /etc/profile of the container

- some instances run with a non-priviledged user. To connect as root run
#+BEGIN_SRC sh
docker exec -u 0 -it peaceful_raman /bin/bash
#+END_SRC
this will also not kill the container when root exits
u - user
0 - root

** Saving changes to a base image
- start the the container
#+BEGIN_SRC sh
docker run -it ubuntu:xenial /bin/bash
#+END_SRC
i - interactive
t - attached to terminal
  
- make the required changes
#+BEGIN_SRC sh
apt-get update
apt-get install telnet ssh
adduser test
#+END_SRC
changes have now been made

- now exit the container
#+BEGIN_SRC sh
exit
#+END_SRC

- confirm that the container has stopped  
#+BEGIN_SRC sh
docker ps
#+END_SRC
this instance shouldn't be present

- now commit the changes to the image file
#+BEGIN_SRC sh
docker commit -m "Installed Telnet, SSH, and added the user test" -a "frank@gmail.com" pedantic_jepsen ubuntusshd:v1
#+END_SRC
m - commit message
a - author
pedantic_jepsen is the image name given by docker
frank/buntusshd:v1 is the new image name

- view docker images
#+BEGIN_SRC sh
docker images
#+END_SRC
frank/ubuntusshd:v1 should now be an option

** Creating Dockerfiles
*** Simple example where ubuntu has a few packages installed
#+BEGIN_SRC sh
# This is a custom ubuntu image with ssh already installed
FROM ubuntu:xenial
MAINTAINER amitchrll <mitchell.alick@gmail.com>
RUN apt-get update -y
RUN apt-get install -y telnet openssh-server
#+END_SRC

- building the image
#+BEGIN_SRC sh
docker build -t="amitchell/ubuntusshdonly:v2" .
#+END_SRC
. - if not being run in the same directory a redirect to the Dockerfile location would take the place of the "."

*** Dockerfile Order of execution
Docker files run from top to bottom linearly
#+BEGIN_EXAMPLE
# Dockerfile based on the latest CentOS 7 images - non-privileged user entry
# FROM always needs to be at the top
FROM centos:latest
MAINTAINER mitchell.alick@gmail.com

# If root isn't being used the new user needs to be created
RUN useradd -ms /bin/bash user
RUN echo "EXPORT 192.168.0.0/24" >> /etc/exports.list

USER user

# If the cmd below is run then the build would fail due to the order. It would be run as user
#RUN echo "EXPORT 192.168.0.0/24" >> /etc/exports.list
#+END_EXAMPLE
if the echo cmd was run after USER user then the build would fail, as it would be run with user's privs

*** Dockerfile Env
we install java 8 and then show how to set env variables for users or system-wide
#+BEGIN_EXAMPLE
# Dockerfile based on the latest CentOS 7 images - non-privileged user entry
# FROM always needs to be at the top
FROM centos:latest
MAINTAINER mitchell.alick@gmail.com

# If root isn't being used the new user needs to be created
RUN useradd -ms /bin/bash user

# all cmds need to be configured to run without user interaction
RUN yum update -y
RUN yum install -y net-tools wget

RUN cd ~ && wget --no-cookies --no-check-certificate --header "Cookie: oraclelicense=accept-securebackup-cookie" http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.rpm

RUN yum localinstall -y ~/jdk-8u131-linux-x64.rpm

USER user

#This will set the user to have the environment variable for JAVA_HOME
RUN cd ~ && echo "export JAVA_HOME=/usr/java/jdk1.8.0_131/jre" >> /home/user/.bashrc

#This is how to set system-wide env variables
ENV JAVA_BIN /usr/java/jdk1.8.0_131/jre/bin
#+END_EXAMPLE

*** Difference between CDM and RUN
RUN is used during container build
CDM is run when the container is started
#+BEGIN_EXAMPLE
# Dockerfile based on the latest CentOS 7 images - non-privileged user entry
# FROM always needs to be at the top
FROM centos:latest
MAINTAINER mitchell.alick@gmail.com

RUN useradd -ms /bin/bash user

CMD "echo" "This is a custom container"

USER user
#+END_EXAMPLE
everytime this container is started the message "This is a custome container" will be printed to the screen

*** ENTRY difference to CDM
#+BEGIN_EXAMPLE
# Dockerfile based on the latest CentOS 7 images - non-privileged user entry
# FROM always needs to be at the top
FROM centos:latest
MAINTAINER mitchell.alick@gmail.com

RUN useradd -ms /bin/bash user

ENTRYPOINT echo "This command will display this message on EVERY container that is run from it"

USER user
#+END_EXAMPLE
We used CDM before to echo a message to screen, the difference is that we can change the behaviour of CDM, but will always print this message.

* Lecture
* Tutorials
*** Containers - Get Started Part 2
https://docs.docker.com/get-started/part2/
- app.py
#+BEGIN_EXAMPLE
from flask import Flask
from redis import Redis, RedisError
import os
import socket

# Connect to Redis
redis = Redis(host="redis", db=0, socket_connect_timeout=2, socket_timeout=2)

app = Flask(__name__)

@app.route("/")
def hello():
    try:
        visits = redis.incr("counter")
    except RedisError:
        visits = "<i>cannot connect to Redis, counter disabled</i>"

    html = "<h3>Hello {name}!</h3>" \
           "<b>Hostname:</b> {hostname}<br/>" \
           "<b>Visits:</b> {visits}"
    return html.format(name=os.getenv("NAME", "world"), hostname=socket.gethostname(), visits=visits)

if __name__ == "__main__":
    app.run(host='0.0.0.0', port=80)
#+END_EXAMPLE

- requirements.txt
#+BEGIN_EXAMPLE
Flask
Redis
#+END_EXAMPLE

- Create image using this directory's Dockerfile
#+BEGIN_SRC sh
docker build -t friendlyname .
#+END_SRC

- Run "friendlyname" mapping port 4000 to 80
#+BEGIN_SRC sh
docker run -p 4000:80 friendlyname
#+END_SRC

- Same thing, but in detached mode
#+BEGIN_SRC sh
docker run -d -p 4000:80 friendlyname
#+END_SRC

- See a list of all running containers
#+BEGIN_SRC sh
docker ps
#+END_SRC

- Gracefully stop the specified container
#+BEGIN_SRC sh
docker stop <hash>
#+END_SRC

- See a list of all containers, even the ones not running
#+BEGIN_SRC sh
docker ps -a
#+END_SRC

- Force shutdown of the specified container
#+BEGIN_SRC sh
docker kill <hash>
#+END_SRC

- Remove the specified container from this machine
#+BEGIN_SRC sh
docker rm <hash>
#+END_SRC

- Remove all containers from this machine
#+BEGIN_SRC sh
docker rm $(docker ps -a -q)
#+END_SRC

- Show all images on this machine
#+BEGIN_SRC sh
docker images -a
#+END_SRC

- Remove the specified image from this machine
#+BEGIN_SRC sh
docker rmi <imagename>
#+END_SRC

- Remove all images from this machine
#+BEGIN_SRC sh
docker rmi $(docker images -q)
#+END_SRC

- Log in this CLI session using your Docker credentials
#+BEGIN_SRC sh
docker login
#+END_SRC

- Tag <image> for upload to registry
#+BEGIN_SRC sh
docker tag <image> username/repository:tag
#+END_SRC

- Upload tagged image to registry
#+BEGIN_SRC sh
docker push username/repository:tag
#+END_SRC

- Run image from a registry
#+BEGIN_SRC sh
docker run username/repository:tag
#+END_SRC

*** Services - Get Started Part 3
https://docs.docker.com/get-started/part2/

docker-compose.yml
#+BEGIN_EXAMPLE
version: "3"
services:
  web:
    # replace username/repo:tag with your name and image details
    image: username/repository:tag
    deploy:
      replicas: 5
      resources:
        limits:
          cpus: "0.1"
          memory: 50M
      restart_policy:
        condition: on-failure
    ports:
      - "80:80"
    networks:
      - webnet
networks:
  webnet:
#+END_EXAMPLE

- Before you can call docker stack, swarm needs to to initiated
#+BEGIN_SRC sh
docker swarm init
#+END_SRC

- Now run the script
#+BEGIN_SRC sh
docker stack deploy -c docker-compose.yml getstartedlab
#+END_SRC

- See a list of 5 containers
#+BEGIN_SRC sh
docker stack ps getstartedlab
#+END_SRC
You can run curl http://localhost several times in a row, or go to that URL in your browser and hit refresh a few times. Either way, youâ€™ll see the container ID change, demonstrating the load-balancing; with each request, one of the 5 replicas is chosen, in a round-robin fashion, to respond.

- To teardown the stack
#+BEGIN_SRC sh
docker stack rm getstartedlab
docker swarm leave --force
#+END_SRC

**** Cmds used
- List all running applications on this Docker host
#+BEGIN_SRC sh
docker stack ls
#+END_SRC

- Run the specified Compose file
#+BEGIN_SRC sh
docker stack deploy -c docker-compose.yml getstartedlab
#+END_SRC

- List the services associated with an app
#+BEGIN_SRC sh
docker stack services getstartedlab
#+END_SRC

- List the running containers associated with an app
#+BEGIN_SRC sh
docker stack ps getstartedlab
#+END_SRC

- Tear down an application
#+BEGIN_SRC sh
docker stack rm getstartedlab
#+END_SRC

* Books
** [[file://home/crito/Documents/SysAdmin/Virt/Docker/Using_Docker.pdf][Using Docker]]
** [[file://home/crito/Documents/SysAdmin/Virt/Docker/Pro_Docker.pdf][Pro Docker]]
** [[file://home/crito/Documents/SysAdmin/Virt/Docker/Learning_Docker.pdf][Learning Docker]]
** [[file://home/crito/Documents/SysAdmin/Virt/Docker/Monitoring_Docker.pdf][Monitoring Docker]]
** [[file://home/crito/Documents/SysAdmin/Virt/Docker/Orchestrating_Docker.pdf][Orchestrating Docker]]
** [[file://home/crito/Documents/SysAdmin/Virt/Docker/Docker_Cookbook.pdf][Docker Cookbook]]

* Links
