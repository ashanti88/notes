#+TAGS: auto


* ansible							       :auto:
HomePage: [[https://www.ansible.com/][ansible.com]]
Galaxy: [[https://galaxy.ansible.com/][galaxy.ansible.com]]

* cmds
[[file://home/crito/org/tech/cmds/ansible.org][ansible]]
[[file://home/crito/org/tech/cmds/ansible-playbook.org][ansible-playbook]]

* Files
/etc/ansible/hosts - this file is the default hosts file that ansible will use

* Description
- RHEL 6 and below can't support Control Persist feature of OpenSSH so falls back to using a python implementation of OpenSSH, 'paramiko'. It is advised if this is the case to use another implementation of Linux as the control machine (fedora, ubuntu etc)
- Using sudo was previously done with the option --ask-sudo-pass, this has now been deprecated for --ask-become-pass
** Inventory
These are the machines that ansible will work against
- defaults to /etc/ansible/hosts 
- a different inventory file can be specified by using the the -i <path> option
- these files use an INI-like format that looks like this:
#+BEGIN_EXAMPLE
mail.example.com

[webservers]
foo.example.com
bar.example.com

[dbservers]
one.example.com
two.example.com
bar.example.com
#+END_EXAMPLE

- for use with vagrant on a local machine it a simple version looks like this
#+BEGIN_EXAMPLE
[vagrant]
testserver	ansible_host=127.0.0.1 ansible_ssh_port=2222 ansible_ssh_user=vagrant ansible_ssh_private_key_file=/home/crito/vagrant/testserver/.vagrant//machines/default/virtualbox/private_key
#+END_EXAMPLE

- a machine may be a member of more than one group, but variable precedence has to be taken into account
- none default ssh port numbers can be added to this file at the end of the machine name
#+BEGIN_EXAMPLE
mail.example.com:4444
#+END_EXAMPLE

- multiple hosts using the same naming convention
#+BEGIN_EXAMPLE
mail[01:50].example.com
#+END_EXAMPLE

* Usage
- only run cmd on specific server in a group
#+BEGIN_SRC sh
ansible app -s -a "service ntpd restart" --limit "192.168.60.4"
ansible app -s -a "service ntpd restart" --limit "*.4"
ansible app -s -a "service ntpd restart" --limit ~".*\.4"
#+END_SRC
This cmd will only be run on the .4 server
first is an exact string match, second is a wildcard match and thrid is a regex match.

** Ad-hoc cmds 
*** System Analysis
- ping testserver that is specified in hosts file
#+BEGIN_SRC sh
ansible testserver -i hosts -m ping
#+END_SRC
-i -this indicates the hosts file to be used, if none set /etc/hosts is used
use the --private-key option to select which which private key to use

- check uptime of testserver
#+BEGIN_SRC sh
ansible testserver -i hosts -m command -a uptime
#+END_SRC

- confirm hostnames of servers
#+BEGIN_SRC sh
ansible multi -a "hostname"
#+END_SRC

- force ansible to use only one fork (stop parallelism)
#+BEGIN_SRC sh
ansible multi -a "hostname" -f 1
#+END_SRC
using this option allows the setting of the number of forks explicitly

- check disk information on servers
#+BEGIN_SRC sh
ansible multi -a "df -h"
#+END_SRC

- check available memory
#+BEGIN_SRC sh
ansible multi -a "free -m"
#+END_SRC
this will use megabyte as the unit, h can be used in its place

- check the date on the servers
#+BEGIN_SRC sh
ansible multi -a "date"
#+END_SRC
- view the /etc/passwd file
#+BEGIN_SRC sh
ansible testserver -i hosts -m command -a "cat /etc/passwd"
#+END_SRC

- check uptime of testserver
#+BEGIN_SRC sh
ansible testserver -i hosts -m command -a "uptime"
#+END_SRC

- check the state of NTP daemon
#+BEGIN_SRC sh
ansible multi -s -m service -a "name=ntpd state=started enabled=yes"
#+END_SRC

- view the /etc/passwd file
#+BEGIN_SRC sh
ansible testserver -i hosts -m command -a "cat /etc/passwd"
#+END_SRC

*** Install
- install nginx
#+BEGIN_SRC sh
ansible testserver -i hosts -m apt -a name=nginx
#+END_SRC

- install ntp on servers
#+BEGIN_SRC sh
ansible multi -s -m yum -a "name=ntp state=present"
#+END_SRC
-s this tells ansilble to use sudo
If sudo password is required add the -k (--ask-sudo-pass) option and this will prompt for the password

- installing django on application server
#+BEGIN_SRC sh
ansible app -s -m yum -a "name=MySQL-python state=present"
ansible app -s -m yum -a "name=python-setuptools state=present"
ansible app -s -m easy_install -a "name=django"
ansible app -a "python -c 'import django; print django.get_version()'"
#+END_SRC
The final line is to confirm the django install

- installing mariadb on database server
#+BEGIN_SRC sh
ansible db -s -m yum -a "name=mariadb-server state=present"
ansible db -s -m service -a "name=mariadb state=started enabled=yes"
ansible db -s -a "iptables -F"
ansible db -s -a "iptables -A INPUT -s 192.168.60.0/24 -p tcp -m tcp --dport 3306 -j ACCEPT"
#+END_SRC
- add the MySQL-python module to allow django to connect to the db
#+BEGIN_SRC sh
ansible db -s -m yum -a "name=MySQL-python state=present"
ansible db -s -m mysql_user -a "name=django host=% password=12345 priv=*.*:ALL state=present"
#+END_SRC
This would this configuration is only for dev environments.
For Production:
Remove test db
Add root user account password
Restrict the IP addr that can connect to 3306

*** Ops
- Sync NTP servers
#+BEGIN_SRC sh
ansible multi -s -a "service ntpd stop"
ansible multi -s -a "ntpdate -q 0.rhel.pool.ntp.org"
ansible multi -s -a "service ntpd start"
#+END_SRC

**** Manage users and Groups
- add an admin group
#+BEGIN_SRC sh
ansible app -s -m group -a "name=admin state=present"
#+END_SRC
To remove a group change the state=absent
system=yes indicates that the group is a system group
gid=[gid] this is to set a specific gid

- add the user frank to the app servers
#+BEGIN_SRC sh
ansible app -s -m user -a "name=frank group=admin createhome=yes"
#+END_SRC
generate_ssh_key=yes will create an ssh key for the user
uid=[uid] this sets a specific uid for the user
shell=[shell] this sets the specific shell for the user
password=[encrypted-password] this sets the users password

- remove the user frank from the app servers
#+BEGIN_SRC sh
ansible app -s -m user -a "name=frank state=absent remove=yes"
#+END_SRC

**** Manage files and directories
- get infomation about a file
#+BEGIN_SRC sh
ansible multi -m stat -a "path=/etc/environment"
#+END_SRC

- copy a file to the servers
#+BEGIN_SRC sh
ansible multi -m copy -a "src=/etc/hosts dest=/tmp/hosts"
#+END_SRC
this can be a file or a directory.
A trailing slash, means only the contents of the directory will be copied
If the trailing slash is omitted the directory is also copied
For large amounts of files use an archinve with the unarchive module

- retrieve a file from the servers
#+BEGIN_SRC sh
ansible multi -s -m fetch -a "src=/etc/hosts dest=/tmp"
#+END_SRC
the files will be returend in directories named by their ip addr
flat=yes this option would retrieve the file without the directories, but unique files names would be needed. Really only of use for a single host.

- Create a directories and files
#+BEGIN_SRC sh
ansible multi -m file -a "dest=/tmp/test mode=644 state=directory"
#+END_SRC

- Create a symlink
#+BEGIN_SRC sh
ansible multi -m file -a "dest=/src/symlink dest=/tmp/symlink owner=root group=root state=link"
#+END_SRC

- Delete directories and files
#+BEGIN_SRC sh
ansible multi -m file -a "dest=/tmp/test state=absent"
#+END_SRC



**** Update system
- Run the update in the background
#+BEGIN_SRC sh
ansible multi -s -B 3600 -a "yum -y update"
#+END_SRC
-B <seconds> - max amount of time to let the job run
-P <seconds> - amount of time between polling the servers, if absent defaults to 10 secs

**** Check log files
tail -f is not possible with ansible, and large amounts of data shouldn't be accessed(> a few KB) by ansible logon to the server individually to get this data if required

- view last few lines of messages log file
#+BEGIN_SRC sh
ansible multi -s -a "tail /var/log/messages"
#+END_SRC

- grep the messages log
#+BEGIN_SRC sh
ansible multi -s -m shell -a "tail /var/log/messages | grep ansible-command | wc -l"
#+END_SRC

**** Manage cron jobs
- add a cron job to run everyday at 4am
#+BEGIN_SRC sh
ansible multi -s -m cron -a "name='daily-cron-all-servers' hour=4 job='/path/to/daily-script.sh'"
#+END_SRC
Ansible assumes * for all values you don't specify (valid values day, hour, minute, month and weekday)
special_time=[value] reboot, yearly or monthly
user=[user] this specifies which user for the cron job to run under

- remove a cron job
#+BEGIN_SRC sh
ansible multi -s -m cron -a "name='daily-cron-all-servers' state=absent"
#+END_SRC

**** VCS
Playbooks should be used for complicated application deployment

- simple application deployment with git module
#+BEGIN_SRC sh
ansible app -s -m git -a "repo=https://github.com/hephaest0s/usbkill.git dest=/opt/myapp"
#+END_SRC
version=1.2.4 - this will ensure that the 1.2.4 branch is checked out, or a specific commit can be used

** Vagrant
*** Configure
to use playbooks with a vm the following needs to be added to the Vagrantfile
#+BEGIN_EXAMPLE
Vagrant.configure("2") do |config|

  #
  # Run Ansible from the Vagrant Host
  #
  config.vm.provision "ansible" do |ansible|
    ansible.playbook = "playbook.yml"
  end

end
#+END_EXAMPLE
*** Sudo
sudo: yes is now deprecated for become: true
*** Example host configurations
**** Two App Servers and a DB Server
/etc/ansible/hosts
this is an example for a vagrant setup
#+BEGIN_EXAMPLE
# Application Servers
[app]
192.168.60.4
192.168.60.5

# Databae Server
192.168.60.6

# Group 'multi' with all servers
[multi:children]
app
db

# Variables that will be applied to all servers
[multi:vars]
ansible_ssh_user=vagrant
ansible_ssh_private_key_file=~/.vagrant.d/insecure_private_key
#+END_EXAMPLE

Vagrantfile
#+BEGIN_EXAMPLE
# -*- mode: ruby -*-
# vi: set ft=ruby :
# This will provision 2 Application Servers and a Database serrver running Centos7

VAGRANTFILE_API_VERSION = "2"

Vagrant.configure(VAGRANTFILE_API_VERSION) do |config|
  config.ssh.insert_key = false
  config.vm.provider :virtualbox do |vb|
    vb.customize ["modifyvm", :id, "--memory", "256"]
  end

  # Application server 1
  config.vm.define "app1" do |app|
    app.vm.hostname = "ans-app1.dev"
    app.vm.box = "centos/7"
    app.vm.network :private_network, ip: "192.168.60.4"
  end

  # Application server 2
  config.vm.define "app2" do |app|
    app.vm.hostname = "ans-app2.dev"
    app.vm.box = "centos/7"
    app.vm.network :private_network, ip: "192.168.60.5"
  end

  # Application server 3
  config.vm.define "db" do |app|
    app.vm.hostname = "ans-db.dev"
    app.vm.box = "centos/7"
    app.vm.network :private_network, ip: "192.168.60.6"
  end
end
#+END_EXAMPLE
    
**** Simple ansible/vagrant setup
These two file should be placed in the vagrant directory
- ansible.cnf
#+BEGIN_EXAMPLE
[defaults]
hostfile = hosts
remote_user = ubuntu
private_key_file = /home/crito/vagrant_boxes/ansible/.vagrant/machines/default/virtualbox/private_key
host_key_checking = False
#+END_EXAMPLE

- hosts
#+BEGIN_EXAMPLE
vm-ubuntu ansible_ssh_host=127.0.0.1 ansible_ssh_port=2222 ansible_ssh_user=ubuntu ansible_ssh_private_key_file=/home/crito/vagrant_boxes/ansible/.vagrant/machines/default/virtualbox/private_key
#+END_EXAMPLE


* Lecture
** Learn you some Ansible for great good! - OpenStack Summit May 2015
url:[[url][https://www.youtube.com/watch?v=qEuk65few9I]]

*** Unified dev, test and deployment environments 
+ can reproduce issues
+ buys caught earlier
+ dev environment templated - all the same
+ speed of work getting started

+ simple way to create identical development environments

*** Configuration Management Tools

Arcane magic --------> Manual Instructions ----------> Scripts ------> CM Tools

+ with the scripts and CM tools we are now able to automate the management.

*** CM Tools
+ its about describing to the tool the environment that is required.

variety - Puppet - 2005
        - Chef   - 2009        Seen as more feature rich
--------------------------------------------------------------
        - Salt   - 2011        Simpler Solutions
        - Ansible- 2012
	  

*** Ansible
+ Orchestration engine for CM and deployment
+ Written in python
+ Uses YAML
+ Playbooks - descriptions of desired states
+ Config specs or explicit cmds

**** Key Points
+ No central configuration server
+ No key mgmt
+ No agent to install on target machine
+ Explicit order
  
**** Requirements
+ SSH access (with key or password)
+ Need Python installed on target machine

**** Modules
+ Hundreds of them. They know stuff....
  - Command
  - shell script
  - install pkg
  - Network Services
  - Database Services
Many more.....

**** How does it work

           Playbook      Python Mod   ssh              ssh     Run Mod
  Laptop ------------->  "Apache2" --------> Run Mod -------> (then del) 
     |                                                            |
     |                                                            |
     -------------------------------------------------------------
                           Return Results
			   
+ once Ansible has finished all the module code is deleted.

**** Inventory and groups
+ Define hosts, organised into groups 
  - by function
  - by location
  - by hosting provider

+ Naming of groups is arbitory

**** Adhoc commands
+ Single commands applied to groups
> ansible -i hosts europe -a "uname -a"
> ansible -i hosta frontend -a "/sbin/reboot" -f 3
-i - host file
-a - command

+ actions are either carried out against single units or groups.

**** Playbooks
+ Tell Ansible what to do
+ These are written in YAML
* Tutorial
** [[https://serversforhackers.com/an-ansible-tutorial][Ansible Tutorial - Servers for Hackers]]
** [[https://www.youtube.com/watch?v%3DkHQUzNiKLoU][Introduction to Ansible - Michelle Perz]]
*** What is Ansible
It is a simple automation language that can purfectly describe an IT application infrastructure in Ansible Playbooks.

- cross platform
  - linux, windows, Unix
- Human readable - Yaml
- Version Controlled
  - playbooks are plain-text
    
+ Batteries included
Ansible comes bundled with hundreds of modules

+ Ansible - Complete Automation - All can be done with Ansible
  - App deployment
    - Fabric
    - Capistrano
    - Nolio
  - Multi-Tier Orchestration
    - BMC
    - Mcollective
    - Chef Metal
  - Configuration Management
    - Chef
    - Puppet
    - CFEngine
  - Provisioning
    - Clobber
    - AWS
    - JuJu

*** Installing Ansible 
#+BEGIN_SRC sh
pip install ansible
yum install ansible
apt-get install ansible
#+END_SRC
    
- Playbooks are written in YAML
  - the playbook is executed sequentially
  - invoking ansible modules
  - Modules are "tools in the toolkit"
    - can be written in any language that can be executed in the shell of target machine

*** Key components
+ Inventory
  - these will be the collections of machines
  - example
    - [web]
       webserver1.example.com
       webserver2.example.com

      [db]
      dbserver1.example.com
      
*** Modules
Modules are bits of code transferred to the target system and executed to satisfy the task 
- apt/yum	- service
- copy 		- synchronize
- file 		- template
- get_url 	- uri
- git 		- user
- ping 		- wait_for
- debug 	- assert

- All modules are indexed at http://docs.ansible.com
  
+ Run Cmds
If ansible doesn't have a module that suits your needs there are the "run cmds"
- command
  - takes the cmd and executes it.
- shell
  - executes through a shell like /bin/bash
- script
  - runs a local script on a remote node after transferring it
- raw
  - executes a cmd without going through the Ansible module subsystem

*** Ad-Hoc Cmds
Check all my inventory hosts are ready to be managed by Ansible
#+BEGIN_SRC sh
ansible all -m ping
#+END_SRC
    
Run the uptime command on all hosts in the web group
#+BEGIN_SRC sh
ansible web -m command -a "uptime"
#+END_SRC
    
Displays information on hosts
#+BEGIN_SRC sh
ansible localhost -m setup
#+END_SRC

*** Static Inventory Example
#+BEGIN_SRC sh
[control]
control ansible_host=10.42.0.2

[web]
node-1 ansible_host=10.42.0.6
node-2 ansible_host=10.42.0.7
node-3 ansible_host=10.42.0.8

[haproxy]
haproxy ansible_host=10.42.0.100

[all:vars]
ansible_user=vagrant
ansible_ssh_private_key_file=~/.vagrant.d/insecure_private_key
#+END_SRC

*** Variable Precedence
1.  extra vars
2.  task vars
3.  block vars
4.  role and include vars
5.  play vars_files
6.  play vars_prompt
7.  play vars
8.  set_facts
9.  registered vars
10. host facts
11. playbook host_vars
12. playbook group_vars
13. inventory host_vars
14. inventory group_vars
15. inventory vars
16. role defaults
    
*** Tasks
file - a directory should exist
yum - a package should be installed
service - a service should be running
template - render a configuration file from a template
get_url - fetch an archive file from a url
git - clone a source code repo

- Example tasks in a playbook
#+BEGIN_SRC sh
tasks:
  - name: add cache dir
    file:
      path: /opt/cache
      state: directory

  - name: install nginx
    yum:
      name: nginx
      state: latest

  - name: restart nginx
    service:
      name: nginx
      state: restarted
#+END_SRC

- Handler tasks
these are run at the end of a play
#+BEGIN_SRC sh
tasks:
  - name: add cache dir
    file:
      path: /opt/cache
      state: directory

  - name: install nginx
    yum:
      name: nginx
      state: latest
    notify: restart nginx

handlers:
  - name: restart nginx
    service:
      name: nginx
      state: restarted
#+END_SRC

*** Plays and Playbooks
Plays are ordered sets of tasks to execute against host selections from your inventory. 
A playbook is a file containing one or more plays.

*** Roles
Roles are a packages of closely related Ansible content that can be shared more easily than plays alone.
- Improves readability
- Eases sharing
- Enables Ansible content to exist independently of playbooks
- Provides functional conveniences such as file path ersolution and default values

- Example
site.yml
roles/
    common/
        files/
	template/
	tasks/
	handlers/
	vars/
	defaults/
	meta/
    webservers/
        files/
	template/
	tasks/
	handlers/
	vars/
	defaults/
	meta/
#+BEGIN_SRC sh
- hosts: web
  roles:
    - common
    - webservers
#+END_SRC

*** Using Ansible
- ping hosts
#+BEGIN_SRC sh
ansible -i hosts -m ping
#+END_SRC

- check the setup of the host machines
#+BEGIN_SRC sh
ansible -i hosts -m setup
#+END_SRC

- inatall apache on host machines
#+BEGIN_SRC sh
ansible -i hosts -m yum -a "name=httpd state=present" -b
#+END_SRC
If apache is already installed it will not attempt to reinstall

- remove apache on host machines
#+BEGIN_SRC sh
ansible -i hosts -m yum -a "name=httpd state=absent" -b
#+END_SRC

**** Example Playbook
site.yml
#+BEGIN_SRC sh
- name: install and start apache
  hosts: webservers
  become: yes

  tasks:
  - name: install apache
    yum: name=httpd state=present

  - name: start and enable apache
    service: name=httpd state=started enabled=yes
#+END_SRC

- run a playbook
#+BEGIN_SRC sh
ansible-playbook -i hosts site.yml
#+END_SRC

**** Setting up Roles
#+BEGIN_SRC sh
mkdir roles
cd roles
ansible-galaxy init apache
ansible-galaxy init common
ansible-galaxy init db
ansible-galaxy init php
#+END_SRC
ansible-galaxy init cmd will create a directory with the following directories and files:
- READM.md
- /defaults
- /files
- /handlers
- /meta
- /tasks
- /templates
- /tests
- /vars

***** Apache role
/tasks/main.yml
#+BEGIN_SRC sh
- name: install apache
  yum: name=httpd state=present

- name: insert firewalld rule for httpd
  firewalld: port={{httpd_port}}/tcp permanent=true state=enabled immediate=yes

- name: start and enable apache
  service: name=httpd state=started enabled=yes

- name: configuration SELinux to allow httpd to connect to remote database
  seboolean: name=httpd_can_network_connect_db state=true persistent=yes
#+END_SRC

***** Common role
/tasks/main.yml
#+BEGIN_SRC sh

#+END_SRC

/tasks/selinux.yml
#+BEGIN_SRC sh
- name: install python bindings for selinux
  yum: name{{item}} state=present
  with_itmes:
  - libselinux-python
  - libsemanage-pyton

- name: test to see if selinux is running 
  command: getenforce
  changed_when: false
#+END_SRC

/tasks/ntp.yml
#+BEGIN_SRC sh
- name: install ntp
  yum: name=ntp state=present

- name: configure ntp file
  template: src=ntp.conf.j2 dest=/etc/ntp.conf
  notify: restart ntp

- name: start the ntp service
  service: name:ntpd state=started enabled=yes
#+END_SRC

/templates/ntp.conf.j2
#+BEGIN_SRC sh
driftfile /var/lib/ntp/drift

restrict 127.0.0.1
restrict -6 ::1

server {{ ntpserver }}

includefile /etc/ntp/crypto/pw

keys /etc/ntp/keys
#+END_SRC

/handlers/main.yml
#+BEGIN_SRC sh
- name: restart ntp
  service: name=ntpd state=restarted
#+END_SRC

/tasks/main.yml
#+BEGIN_SRC sh
- include: selinux.yml
- include: ntp.yml

- name: start firewalld
  service: name=firewalld state=started enabled=yes
#+END_SRC

***** DB role
/tasks/main.yml
#+BEGIN_SRC sh
- name: install mariadb package
  yum: name={{item}} state=present
  with_items:
  - mariadb-server
  - MySQL-python

- name: configure SELinux to start mariadb on any port
  seboolean: name=mysql_connect_any state=true persistent=yes

- name: create mariadb config file
  template: src=my.cnf.j2 dest=/etc/my.cnf
  notify: restart mariadb

- name: create mariadb log file
  file: path=/var/log/mysql.log stte=touch owner=mysql group=mysql mode=0775

- name: create mariadb PID directory
  file: path=/var/run/mysqld state=directory owner=mysql group=mysql mode=0775

- name: start mariadb service
  service: name=mariadb state=started enabled=yes

- name: insert firewalld rule
  firewalld: port={{mysql_port}}/tcp permanent=true state=enabled immediate=yes

- name: create application database
  mysql_db: name={{dbname}} state=present

- name: create application database user
  mysql_user: name={{dbuser}} password={{upassword}} priv=*.*:ALL host='%' state=present
#+END_SRC

/tmeplates/my.cnf.j2
#+BEGIN_SRC sh
[mysqld]
datadir=/var/lib/mysql
socket=/var/lib/mysql/mysql.sock
user=mysql
symbolic-links=0
port={{ mysql_port }}

[mysqld_safe]
log-error=/var/log/mysqld.log
pid-file=/var/run/mysqld/mysqld.pid
#+END_SRC

/handlers/main.yml
#+BEGIN_SRC sh
- name: restart mariadb
  service: name=mariadb state=restarted
#+END_SRC

***** PHP role
/tasks/main.yml
#+BEGIN_SRC sh
- name: insatll php and git
  yum: name={{item}} state=persent
  with_items:
  - php
  - php-mysql
  - git

- name: copy the code from repo
  git: repo={{repository}} dest=/var/www/html/

- name: create the index.php file
  template: src=index.php.j2 dest=/var/www/html/index.php
#+END_SRC

/templates/index.php.j2
#+BEGIN_SRC sh
<html>
  <head>
    <title>Ansible Application</title>
  </head>
  <body>
    <h1>Hello World</h1>
  <?php
    Print "Hello, World! I am a webserver configued using Ansible";
  ?>
  </body>
</html>
#+END_SRC

**** site.yml
#+BEGIN_SRC sh
- name: apply common configuration to all hosts
  hosts: all
  become: yes

  roles:
  - common

- name: configure and deploy the db server
  hosts: dbservers
  become: yes

  roles:
  - db

- name: configure and deploy the web server
  hosts: webservers
  become: yes

  roles:
  - apache
  - php
#+END_SRC

**** Run the playbook
#+BEGIN_SRC sh
ansible-playbook -i hosts site.yml
#+END_SRC

* Books
** [[file://home/crito/Documents/SysAdmin/Mgmt/Ansible/Ansible_Playbook_Essentials.pdf][Ansible Playbook Essentials - Packt]]
     - [[https://github.com/schoolofdevops/ansible-playbook-essentials][Github - files for book]]

[[file://home/crito/Documents/SysAdmin/Mgmt/Ansible/Ansible-Up_&_Running.pdf][Ansible-Up & Running]]
[[file://home/crito/Documents/SysAdmin/Mgmt/Ansible/Ansible_for_DevOps.pdf][Ansible for DevOps]]

** [[file://home/crito/Documents/SysAdmin/Mgmt/Ansible/Ansible_Up_and_Running.pdf][Ansible Up & Running]]
** [[file://home/crito/Documents/SysAdmin/Mgmt/Ansible/Ansible_for_DevOps.pdf][Ansible for DevOps]]

* Links
[[https://galaxy.ansible.com/][Ansible Galaxy - A git for sharing roles]]
[[https://www.ansible.com/get-started][Ansible - Get Started]]
